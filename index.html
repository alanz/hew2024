<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>ghc-exactprint (HEW 2024)</title>
<meta name="author" content="Alan Zimmerman"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/white_contrast_compact_verbatim_headers.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="table-of-contents-section">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#slide-org5943ebc">ghc-exactprint</a></li>
<li><a href="#slide-org7804345">About Me</a></li>
<li><a href="#slide-org9335842">This Talk</a></li>
<li><a href="#slide-org79ff377">Problem Being Solved</a></li>
<li><a href="#slide-org945eacb">What it means inside GHC</a></li>
<li><a href="#slide-org594a6dd">What it means outside GHC</a></li>
<li><a href="#slide-org027b450">Future</a></li>
<li><a href="#slide-orgc63d15b">End</a></li>
</ul>
</div>
</div>
</section>
<section>
<section id="slide-org5943ebc">
<h2 id="org5943ebc">ghc-exactprint</h2>
<p>
Alan Zimmerman
</p>

<p>
<a href="https://social.coop/@alanz"><code>@alanz@social.coop</code></a>
</p>

<p>
Haskell Ecosystem Workshop,
ZuriHac, 2024-06-07
</p>

</section>
</section>
<section>
<section id="slide-org7804345">
<h2 id="org7804345">About Me</h2>
<ul>
<li>Learned Haskell in 2012</li>
<li>First GHC commit Sep 2014</li>
<li>Decided to resurrect HaRe, using GHC backend</li>
<li>Led to haskell-ide-engine, to expose it to users</li>
<li>And into GHC to make it useful for this</li>

</ul>
<div class="slide-footer">Footer</div>

</section>
</section>
<section>
<section id="slide-org9335842">
<h2 id="org9335842">This Talk</h2>
<ul>
<li>Overview of the problem being solved</li>
<li>What it means inside GHC</li>
<li>What it means outside GHC</li>

</ul>

</section>
</section>
<section>
<section id="slide-org79ff377">
<h2 id="org79ff377">Problem Being Solved</h2>
<p>
To allow a tool to
</p>
<ul>
<li>start from a GHC ParsedSource,</li>
<li>make changes to it,</li>
<li>print source reflecting the changes.</li>
<li>And only the changes.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgaed2592">
<h3 id="orgaed2592">Start from GHC ParsedSource</h3>
<ul>
<li>It must accurately reflect the input source</li>
<li>Literals
Add detail: (AZ note, see LiteralsTest.hs in testsuite)</li>
<li>‘Trivia’
Things like keywords, commas, semicolons, brackets of all kinds</li>
<li>Spacing - via SrcSpan</li>

</ul>

</section>
</section>
<section>
<section id="slide-org7748e24">
<h3 id="org7748e24">Literals Detail</h3>
<p>
TBD
(AZ note, see LiteralsTest.hs in testsuite, and HIW2021 slide)
</p>

</section>
</section>
<section>
<section id="slide-org90a9c28">
<h3 id="org90a9c28">Capturing Trivia</h3>
<p>
TBD
</p>

</section>
</section>
<section>
<section id="slide-org865b94c">
<h3 id="org865b94c">Spacing</h3>
<ul>
<li>Spacing is a funny thing.</li>
<li>To start with, it is just a given. This is where things are in the source, all wrapped in a SrcSpan</li>
<li>But when you change things it gets complicated
<ul>
<li>Add or delete lines</li>
<li>Move a block of code from one place to another
<ul>
<li>Which can also change its indentation</li>

</ul></li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org9d4854c">
<h3 id="org9d4854c">Principles for Spacing</h3>
<ul>
<li>A located AST element is treated as a unit
<ul>
<li>We believe its span start point</li>
<li>We believe its span end point</li>
<li>Nothing is printed outside its span</li>

</ul></li>
<li>In other words, it is internally consistent
<ul>
<li>If we apply a constant (line,col) offset to the whole thing, it
will still print properly</li>

</ul></li>
<li>Implication
<ul>
<li>If we do some book-keeping about the start offset, we can print it
anywhere</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orge571105">
<h3 id="orge571105">Spacing : the trick</h3>
<ul>
<li>An internally consistent AST element has absolute locations</li>
<li>But when we print, we have a print head that we advance</li>
<li>By distances calculated from the absolute locations</li>

</ul>
<p>
So
</p>
<ul>
<li>We track two locations
<ul>
<li>The output print position, which always advances as we print</li>
<li>The offset calculation position, which we reset every time we enter a span
<ul>
<li>(remember “we believe the start position of a span”)</li>

</ul></li>
<li>And also set every time we exit a span (“belief”)</li>
<li>Otherwise it also advances as we print</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org715dce0">
<h3 id="org715dce0">Spacing : the missing piece</h3>
<p>
There is one remaining problem
</p>
<ul>
<li>How do we change things?
<ul>
<li>If we delete, there will be a gap</li>
<li>If we add something, there will be some kind of jump</li>

</ul></li>
<li>Deltas
<ul>
<li>At the point where we change from one internally consistent point
to another, we supply the delta directly</li>
<li>Instead of calculating it from the offset calculation position.</li>
<li>And then set the offset calculation position according to the next
actual span we see</li>
<li>We believe the start position in a span</li>
<li>It will come after a delta, so the spacing is known</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-org2cfbee4">
<h3 id="org2cfbee4">Spacing : size changes</h3>
<ul>
<li>A typical change is to rename a variable.</li>
<li>The name may be longer or shorter.</li>
<li>The spacing calculation to the start point is unchanged, so all is good</li>
<li>When we finish, we set the offset calculation position to the end of the span
(We believe the end position)</li>
<li>And so following spacing calculations are unaffected.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org540c023">
<h3 id="org540c023">Spacing : size changes 2</h3>
<ul>
<li>The same principle holds for bigger changes.</li>
<li>If we add additional content inside a span, it does not matter,</li>
<li>The “contract” with the surroundings is the start of the span for
entry spacing</li>
<li>And the end of the span for exit spacing</li>

</ul>

</section>
</section>
<section>
<section id="slide-org51c8b10">
<h3 id="org51c8b10">Spacing : layout</h3>
<p>
Haskell is a layout-sensitive language
</p>

<p>
AZ Note: Do we need this slide?
         We will have to go down a rabbit hole for it
</p>


</section>
</section>
<section>
<section id="slide-orgccbaea2">
<h3 id="orgccbaea2">Order in lists</h3>
<ul>
<li><code>ParsedSource</code> is not a completely accurate reflection of the original source.</li>
<li><code>ValBinds</code> separates out ~Sig~s and ~Bind~s</li>
<li><code>ClsInstDecl</code> separates out ~Bind~s,
~Sig~s, Type family instances and Data family instances</li>
<li>For both of these, the original source can have them in any order.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org5381bb9">
<h3 id="org5381bb9">Order in lists 2</h3>
<p>
 AST implements “Trees That Grow”
This means extra information can be carried, computed via type classes
Used for Exact Print Annotations (EPA)
Uses two mechanisms
XRec for Located things
TTG extension points for the rest
</p>

<ul>
<li>For an unmodified AST there is no problem, you just sort by start of
span.</li>
<li>But a modified one may have rearranged the existing ones, or brought
in ones from elsewhere.</li>
<li>And may have adjusted the spacing with explicit deltas.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org70119c1">
<h3 id="org70119c1">Order in lists 3 : Solution</h3>
<ul>
<li>Each specific list is physically ordered, so for <code>ValBinds</code> we know
the order of the sigs, and of the binds.</li>
<li>But we don’t know the interleaving.</li>
<li>We supply this in an <code>AnnSortKey</code>, which drives a merge process.</li>
<li>It keeps a list of <code>SigDTag</code> or <code>BindTag</code> for
a <code>ValBind</code>, telling which list to draw from each time.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org52fb2d4">
<h3 id="org52fb2d4">Comments</h3>
<ul>
<li>Comments are the ultimate “trivia”. They have no influence on
overall spacing and layout, but need to be preserved precisely.</li>
<li>They can also occur absolutely anywhere in the source file.</li>
<li>So we keep them in the "<code>SrcSpan</code> on steroids" we wrap
everything in, and fit them in when we print, if they fit into the
current gap.</li>
<li>It’s more complicated than that, but we will look into detail later.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org0d85b94">
<h3 id="org0d85b94">Trailing Items</h3>
<ul>
<li>The consistency belief we base everything on is that everything fits
inside the AST Element span.</li>
<li>This is true for everything, except trailing items.</li>
<li>If you consider a list of items, each item is a standalone entity</li>
<li>The commas exist as part of the surrounding structure.</li>
<li>So if you move the item elsewhere, or replace it with something
else, the trailing comma should be managed as part of that location.</li>
<li>Others are semicolons, vertical bars, single and double arrows</li>

</ul>


</section>
</section>
<section>
<section id="slide-orgd7eda6f">
<h3 id="orgd7eda6f">End of Hand Wavy Part</h3>
<ul>
<li>Hopefully you now have a high level understanding of what the exact
print annotations are for.</li>
<li>Now we can look into some details of how things are captured.</li>

</ul>


</section>
</section>
<section>
<section id="slide-org945eacb">
<h2 id="org945eacb">What it means inside GHC</h2>
<p>
Time to dive into the detail. Two main divisions
</p>
<ul>
<li>Located things</li>
<li>Internal Annotations</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb3a74d1">
<h3 id="orgb3a74d1">Trees That Grow</h3>
<ul>
<li>GHC AST implements “Trees That Grow”</li>
<li>This means extra information can be carried, computed via type classes</li>
<li>Used for Exact Print Annotations (EPA)</li>
<li>Uses two mechanisms
<ul>
<li><code>XRec</code> for Located things [AZ note: not part of TTG]</li>
<li>TTG extension points for the rest</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org97254bb">
<h3 id="org97254bb">Terminology</h3>
<ul>
<li>AST: <code>ParsedSource</code></li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">ParsedSource</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Located</span> (<span style="color: #228b22;">HsModule</span> <span style="color: #228b22;">GhcPs</span>)
</pre>
</div>

<p>
For now we accept <code>GhcPs</code> as simply a marker of the AST from the
parsing phase.
</p>

</section>
</section>
<section>
<section id="slide-org8885277">
<h3 id="org8885277">Located Things</h3>
<p>
The AST is layered, in that alternate layer &#x2026;
</p>

</section>
<section id="slide-orgec52d02">
<h4 id="orgec52d02">Location</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">XRec</span> p a <span style="color: #a0522d;">=</span> r <span style="color: #a0522d;">|</span> r <span style="color: #a0522d;">-&gt;</span> a
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">Anno</span> a <span style="color: #a0522d;">=</span> b
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">XRec</span> (<span style="color: #228b22;">GhcPass</span> p) a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> (<span style="color: #228b22;">Anno</span> a) a
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Anno</span> (<span style="color: #228b22;">HsExpr</span> (<span style="color: #228b22;">GhcPass</span> p)) <span style="color: #a0522d;">=</span> <span style="color: #228b22;">SrcSpanAnnA</span>
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">LocatedA</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> <span style="color: #228b22;">SrcSpanAnnA</span>
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">SrcSpanAnnA</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpAnn</span> <span style="color: #228b22;">AnnListItem</span>
</pre>
</div>

</section>
<section id="slide-orgb812346">
<h4 id="orgb812346">EpAnn</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpAnn</span> ann <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpAnn</span>
         { entry    <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">Anchor</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">basically SrcSpan when parsed</span>
         , anns     <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>ann
         , comments <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">EpAnnComments</span>
         }
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">Anchor</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaLocation</span>
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">EpaLocation</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaLocation'</span> [<span style="color: #228b22;">LEpaComment</span>]
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpaLocation'</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaSpan</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">SrcSpan</span>
                    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">EpaDelta</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">DeltaPos</span> <span style="color: #a0522d;">!</span>a
</pre>
</div>

</section>
<section id="slide-orgbbcc810">
<h4 id="orgbbcc810"><code>AnnListItem</code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #8b2252;">-- | Annotation for items appearing in a list. They can have one or</span>
<span style="color: #8b2252;">-- more trailing punctuations items, such as commas or semicolons.</span>
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">AnnListItem</span>
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AnnListItem</span> {
      lann_trailing  <span style="color: #a0522d;">::</span> [<span style="color: #228b22;">TrailingAnn</span>]
      }
</pre>
</div>

</section>
<section id="slide-org9c0eed8">
<h4 id="org9c0eed8">Sanity check</h4>
<p>
Tie up to prior hand wavy part
</p>
<pre class="example" id="org0ea9f9f">
(L
 (EpAnn
  (EpaSpan { DumpParsedAst.hs:5:1-16 })
  (AnnListItem
   [])
  (EpaComments
   []))
   ...
</pre>

<ul>
<li><code>SrcSpan</code> we "believe" is the one in the <code>EpAnn</code> <code>entry</code>, using the
<code>EpaSpan</code> constructor.</li>
<li>If we need to move things around, the surgery happens by replacing
it with an appropriate <code>EpaDelta</code> version, just for the
point where the change happens.</li>

</ul>

<aside class="notes">
<ul>
<li>After this deep dive into types, let's come up for air a bit.</li>
<li>If you recall in the handwavy part we spoke about span being the
source of truth, the thing we believe.</li>
<li>For ghc-exactprint old hands, makeDeltaAst is no longer required (but still exists)</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org0dd209f">
<h3 id="org0dd209f">"Trivia"</h3>
<ul>
<li>everything that is not a location, comment, or surrounding
information, but is needed for exact printing.
<ul>
<li><code>SourceText</code>,</li>
<li>keywords (via <code>AnnKeywordId</code> or <code>EpToken</code>)</li>

</ul></li>

</ul>

</section>
<section id="slide-org47cd811">
<h4 id="org47cd811"><code>AnnKeywordId</code></h4>
<p>
Original mechanism
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">AnnKeywordId</span>
    <span style="color: #a0522d;">...</span>
    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AnnIn</span>
    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AnnLet</span>
</pre>
</div>

</section>
<section id="slide-org4d6a12c">
<h4 id="org4d6a12c"><code>EpToken</code></h4>
<p>
New mechanism. May eventually supplant <code>AnnKeywordId</code>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpToken</span> (tok <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Symbol</span>)
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">NoEpTok</span>
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">EpTok</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">EpaLocation</span>
</pre>
</div>

<p>
Used as a type <code>EpTok "let"</code>
</p>

<p class="fragment">
Extract string for printing
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">getEpTokenString</span> <span style="color: #a0522d;">::</span> <span style="color: #a020f0;">forall</span> tok<span style="color: #a0522d;">.</span> <span style="color: #228b22;">KnownSymbol</span> tok <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">EpToken</span> tok <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Maybe</span> <span style="color: #228b22;">String</span>
<span style="color: #0000ff;">getEpTokenString</span> <span style="color: #228b22;">NoEpTok</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Nothing</span>
<span style="color: #0000ff;">getEpTokenString</span> (<span style="color: #228b22;">EpTok</span> <span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Just</span> <span style="color: #a0522d;">$</span> symbolVal (<span style="color: #228b22;">Proxy</span> <span style="color: #a0522d;">@</span>tok)
</pre>
</div>


</section>
<section id="slide-orgb19e193">
<h4 id="orgb19e193">"Trivia" storage</h4>
<p>
Stored in the TTG extension points.
</p>

<p>
Refresher
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">HsExpr</span> p
  <span style="color: #a0522d;">...</span>
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">HsLet</span> (<span style="color: #228b22;">XLet</span> p) (<span style="color: #228b22;">HsLocalBinds</span> p) (<span style="color: #228b22;">LHsExpr</span>  p)

<span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">XLet</span> x
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">XLet</span> <span style="color: #228b22;">GhcPs</span> <span style="color: #a0522d;">=</span> (<span style="color: #228b22;">EpToken</span> <span style="color: #8b2252;">"let"</span>, <span style="color: #228b22;">EpToken</span> <span style="color: #8b2252;">"in"</span>)
</pre>
</div>


</section>
</section>
<section>
<section id="slide-org594a6dd">
<h2 id="org594a6dd">What it means outside GHC</h2>
<ul>
<li>The Exact Print Annotations are packaged for use in <a href="https://hackage.haskell.org/package/ghc-exactprint">ghc-exactprint</a></li>
<li>Generally a "hidden" library, enabling others
<ul>
<li>hlint apply hints</li>
<li>various plugins in HLS</li>
<li>built for HaRe, but that now languishes</li>
<li>retrie</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org2315a32">
<h3 id="org2315a32">ghc-exactprint big picture</h3>
<ul>
<li>Parse</li>
<li>Transform</li>
<li>Print</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgda7e6b6">
<h3 id="orgda7e6b6">ghc-exactprint parsing</h3>
<ul>
<li><code>parseModule</code></li>
<li>"best effort" with CPP
<ul>
<li>compares original with preprocessed, and turns the delta into
comments</li>
<li>cannot work if <code>#define XX Blah</code> and then <code>XX</code> is used. <code>XX</code> added as a comment, as well as <code>Blah</code></li>

</ul></li>
<li>Honours pragmas, but you need to set <code>DynFlags</code> for any e.g. project-wide options</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd824f48">
<h3 id="orgd824f48">ghc-exactprint transform</h3>
<ul>
<li>The reason <code>ghc-exactprint</code> exists</li>
<li>Intention: smallest changes possible</li>

</ul>

</section>
<section id="slide-orgb5909a1">
<h4 id="orgb5909a1">Comments</h4>
<p>
Stored in <code>EpAnn</code>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpAnnComments</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaComments</span>
                        { priorComments <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>[<span style="color: #228b22;">LEpaComment</span>] }
                   <span style="color: #a0522d;">|</span> <span style="color: #228b22;">EpaCommentsBalanced</span>
                        { priorComments     <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>[<span style="color: #228b22;">LEpaComment</span>]
                        , followingComments <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>[<span style="color: #228b22;">LEpaComment</span>] }
</pre>
</div>

<p>
Once you decide to move thing around, you need to decide which
comments to bring along.
</p>

</section>
<section id="slide-orgc2db500">
<h4 id="orgc2db500"><code>balanceComments</code></h4>
<p>
<code>ghc-exactprint</code> has <code>balanceComments</code> and <code>balanceCommentsList</code>
</p>

<p>
These use heuristics to "attach" comments to the appropriate top level
declaration.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>


<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> 3
<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">bar</span> <span style="color: #a0522d;">=</span> 2
</pre>
</div>


</section>
<section id="slide-orgc30e4bb">
<h4 id="orgc30e4bb">becomes</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> 3
<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">bar</span> <span style="color: #a0522d;">=</span> 2
</pre>
</div>

</section>
<section id="slide-org98f0272">
<h4 id="org98f0272"><code>FunBind</code> comments</h4>
<ul>
<li><code>FunBind</code> is weird</li>
<li>it combines all the equations for a particular function</li>
<li>each shows up as a <code>Match</code>, which is self-contained</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>


<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #228b22;">True</span> <span style="color: #a0522d;">=</span> 3
<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">=</span> 2
<span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing second fun</span>
</pre>
</div>

</section>
<section id="slide-org48cb44c">
<h4 id="org48cb44c">becomes</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>
</pre>
</div>

<p>
On FunBind prior comments
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
</pre>
</div>

<p>
First match (OOPS, BUG in 1.10.0.0)
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">foo</span> <span style="color: #228b22;">True</span> <span style="color: #a0522d;">=</span> 3
</pre>
</div>

<p>
Second match
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">=</span> 2
</pre>
</div>

<p>
On FunBind following comments
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing second fun</span>
</pre>
</div>

</section>
<section id="slide-orgf864f98">
<h4 id="orgf864f98">Produced by</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">test</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">TestList</span> [mkTestModChange libdir balanceComments <span style="color: #8b2252;">"AFile.hs"</span>]

<span style="color: #0000ff;">balanceComments</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Changer</span>
<span style="color: #0000ff;">balanceComments</span> _libdir lp <span style="color: #a0522d;">=</span> return <span style="color: #a0522d;">$</span> replaceDecls lp ds'
  <span style="color: #a020f0;">where</span>
    ds <span style="color: #a0522d;">=</span> hsDecls lp
    ds' <span style="color: #a0522d;">=</span> balanceCommentsList ds
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org540d865">
<h3 id="org540d865"><code>class HasDecls</code></h3>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">class</span> (<span style="color: #228b22;">Data</span> t) <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">HasDecls</span> t <span style="color: #a020f0;">where</span>
    hsDecls <span style="color: #a0522d;">::</span> t <span style="color: #a0522d;">-&gt;</span> [<span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span>]
    replaceDecls <span style="color: #a0522d;">::</span> t <span style="color: #a0522d;">-&gt;</span> [<span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span>] <span style="color: #a0522d;">-&gt;</span> t
</pre>
</div>

<aside class="notes">
<ul>
<li><p>
hasDecls
</p>
<ul>
<li>Return the 'HsDecl's that are directly enclosed in the</li>

</ul>
<p>
given syntax phrase. They are always returned in the wrapped
'HsDecl' form, even if orginating in local decls. This is safe,
as annotations never attach to the wrapper, only to the wrapped
item.
</p></li>
<li><p>
replaceDecls
</p>
<ul>
<li></li>

</ul>
<p>
Replace the directly enclosed decl list by the given
decl list. As parto of replacing it will update list order
annotations, and rebalance comments and other layout changes as needed.
</p></li>

</ul>
<p>
&#x2013;
For example, a call on replaceDecls for a wrapped 'FunBind' having no
where clause will convert
&#x2013;
@
&#x2013; |This is a function
foo = x &#x2013; comment1
&#x2013;
in to
&#x2013;
&#x2013; |This is a function
foo = x &#x2013; comment1
  where
    nn = 2
</p>

</aside>

</section>
<section id="slide-org7082f63">
<h4 id="org7082f63"><code>replaceDecls</code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #8b2252;">-- |This is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> x <span style="color: #b22222;">-- </span><span style="color: #b22222;">comment1</span>
<span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing comment</span>
</pre>
</div>

<p>
to
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #8b2252;">-- |This is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> x <span style="color: #b22222;">-- </span><span style="color: #b22222;">comment1</span>
  <span style="color: #a020f0;">where</span>
    nn <span style="color: #a0522d;">=</span> 2
<span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing comment</span>
</pre>
</div>

</section>
<section id="slide-orge283671">
<h4 id="orge283671">code for the replace</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">addLocaLDecl1</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Changer</span>
<span style="color: #0000ff;">addLocaLDecl1</span> libdir top <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">do</span>
  <span style="color: #228b22;">Right</span> (<span style="color: #228b22;">L</span> ld (<span style="color: #228b22;">ValD</span> <span style="color: #a020f0;">_</span> decl)) <span style="color: #a0522d;">&lt;-</span> withDynFlags libdir (<span style="color: #a0522d;">\</span>df <span style="color: #a0522d;">-&gt;</span> parseDecl df <span style="color: #8b2252;">"decl"</span> <span style="color: #8b2252;">"nn = 2"</span>)
  <span style="color: #a020f0;">let</span>
      decl' <span style="color: #a0522d;">=</span> setEntryDP (<span style="color: #228b22;">L</span> ld decl) (<span style="color: #228b22;">DifferentLine</span> 1 5)
      (de1<span style="color: #228b22;">:</span>d2<span style="color: #228b22;">:</span>d3<span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> hsDecls top
      (de1',d2') <span style="color: #a0522d;">=</span> balanceComments de1 d2
      (de1'',<span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> modifyValD (getLocA de1') de1' <span style="color: #a0522d;">$</span> <span style="color: #a0522d;">\</span>_m d <span style="color: #a0522d;">-&gt;</span>
                   ((wrapDecl decl' <span style="color: #228b22;">:</span> d), <span style="color: #228b22;">Nothing</span>)
  return <span style="color: #a0522d;">$</span> replaceDecls top [de1'', d2', d3]
</pre>
</div>

</section>
<section id="slide-org492a67a">
<h4 id="org492a67a"><code>modifyValD</code></h4>
<ul>
<li>Remember <code>FunBind</code>?</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a0522d;">..</span>
[ma1,_ma2] <span style="color: #a0522d;">=</span> ms <span style="color: #b22222;">-- </span><span style="color: #b22222;">of de1</span>
(de1',<span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> modifyValD (getLocA ma1) de1 <span style="color: #a0522d;">$</span> <span style="color: #a0522d;">\</span>_m decls <span style="color: #a0522d;">-&gt;</span>
             (newDecl <span style="color: #228b22;">:</span> decls, <span style="color: #228b22;">Nothing</span>)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Decl</span>  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span>
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">PMatch</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">LMatch</span> <span style="color: #228b22;">GhcPs</span> (<span style="color: #228b22;">LHsExpr</span> <span style="color: #228b22;">GhcPs</span>)
<span style="color: #0000ff;">modifyValD</span>
   <span style="color: #a0522d;">::</span> <span style="color: #a020f0;">forall</span> t<span style="color: #a0522d;">.</span> <span style="color: #228b22;">SrcSpan</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Decl</span>
   <span style="color: #a0522d;">-&gt;</span> (<span style="color: #228b22;">PMatch</span> <span style="color: #a0522d;">-&gt;</span> [<span style="color: #228b22;">Decl</span>] <span style="color: #a0522d;">-&gt;</span> ([<span style="color: #228b22;">Decl</span>], <span style="color: #228b22;">Maybe</span> t))
   <span style="color: #a0522d;">-&gt;</span> (<span style="color: #228b22;">Decl</span>, <span style="color: #228b22;">Maybe</span> t)
</pre>
</div>


<aside class="notes">
<p>
&#x2013; |Modify a 'LHsBind' wrapped in a 'ValD'. For a 'PatBind' the
&#x2013; declarations are extracted and returned after modification. For a
&#x2013; 'FunBind' the supplied 'SrcSpan' is used to identify the specific
&#x2013; 'Match' to be transformed, for when there are multiple of them.
</p>

<p>
Note: now that everything is pure, and connected, pretty much not
needed.
</p>

</aside>

</section>
<section id="slide-org8c399be">
<h4 id="org8c399be">packFunBind, unpackFunBind</h4>
<p>
And packFunDecl, unpackFunDecl
</p>

</section>
<section id="slide-org342784b">
<h4 id="org342784b">addToList etc</h4>

</section>
<section id="slide-org6ee78c8">
<h4 id="org6ee78c8">replaceDecls sort order</h4>
<ul>
<li>Remember <code>AnnSortKey</code>?</li>
<li>It is populated in <code>replaceDecls</code></li>
<li><code>captureOrderBinds</code></li>
<li><code>replaceDeclsClassDecl</code> (and <code>hsDeclsClassDecl</code>)</li>

<li><p>
<code>oderedDecls</code>
When <code>NoAnnSortKey</code>,
</p>
<ul>
<li>Assume working with an unchanged AST</li>
<li>use the locations of the decls and sort</li>

</ul>
<p>
When <code>AnnSortKey DeclTag</code>
</p>
<ul>
<li>Build <code>Map.Map DeclTag [LHsDecl GhcPs]</code> from assorted <code>ClassDecl</code> parts</li>
<li></li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org582f8b1">
<h3 id="org582f8b1">Summary</h3>
<ul>
<li>balance comments</li>
<li>manage funbind comment details</li>
<li>manage <code>where</code> for adding/removing decls to <code>HsValBinds</code></li>
<li>track sort order</li>
<li>wrap/unwrap binds</li>

</ul>

</section>
</section>
<section>
<section id="slide-org7d17dbb">
<h3 id="org7d17dbb">ghc-exactprint print</h3>
<p>
This is the heart of the thing
</p>

<p>
But will not look in detail, it is too complex
</p>

<p>
Suffice to say,
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">exactPrint</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">ExactPrint</span> ast <span style="color: #a0522d;">=&gt;</span> ast <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">String</span>
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org0566411">
<h3 id="org0566411">Name tie-ups</h3>
<ul>
<li>All <code>RdrName</code> s in the AST are <code>LocatedN</code>, containing
a <code>SrcSpan</code> when originally parsed.</li>
<li>The <code>RenamedSource</code> does not remove named locations,
although it may move them around a bit.</li>
<li><p>
So perform a generic traversal of the <code>RenamedSource</code>,
building a map of
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #228b22;">SrcSpan</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Name</span>
</pre>
</div></li>

</ul>


</section>
</section>
<section>
<section id="slide-org027b450">
<h2 id="org027b450">Future</h2>
<ul>
<li>Fixity info</li>
<li><code>GHC_CPP</code></li>
<li>Free vars?</li>
<li>Easy Export of Name table for lookup?</li>
<li>ghc-exactprint API
<ul>
<li>currently provisional</li>
<li>should it be split?</li>
<li>where should it live?</li>

</ul></li>
<li>Link-up with ghc-lib-parser</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgc63d15b">
<h2 id="orgc63d15b">End</h2>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: false,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'linear',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
