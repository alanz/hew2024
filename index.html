<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>ghc-exactprint (HEW 2024)</title>
<meta name="author" content="Alan Zimmerman"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/white_contrast_compact_verbatim_headers.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>

<link rel="stylesheet" href="./reveal.js/plugin/toc-progress/toc-progress.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">

<section>
<section id="slide-org55a2ec7">
<h2 id="org55a2ec7">ghc-exactprint</h2>
<p>
Alan Zimmerman
</p>

<p>
<a href="https://social.coop/@alanz"><code>@alanz@social.coop</code></a>
</p>

<p>
Haskell Ecosystem Workshop,
ZuriHac, 2024-06-07
</p>

</section>
</section>
<section>
<section id="slide-org550a02e" data-timing="120">
<h2 id="org550a02e">About Me</h2>
<ul>
<li>Learned Haskell in 2012</li>
<li>Decided to resurrect HaRe, using GHC backend</li>
<li>First GHC commit Sep 2014</li>
<li>Led to haskell-ide-engine, to expose it to users</li>

</ul>

<aside class="notes">
<ul>
<li>Started with projecteuler. Got to 120 or so</li>
<li>First HaRe commit Sep 2012</li>
<li>First commit was to start removing "landmines" from the AST.
<ul>
<li>First API Annotations commit Nov 2014</li>

</ul></li>
<li>HIE: Pre-LSP. I had seen omnisharp, its precursor</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org92c0410">
<h2 id="org92c0410">This Talk</h2>
<ul>
<li>What is the problem being solved</li>
<li>What it means inside GHC</li>
<li>How it is used outside GHC</li>

</ul>

<aside class="notes">
<ul>
<li>This is a large topic, I can only cover osme of it. chat to me at ZuriHac</li>
<li>First a Hand-wavy attempt to motivate the problem being solved</li>
<li>Then how we capture the information needed inside GHC, aimed at
GHC developers</li>
<li>Finally how to use it in the real world, aimed at ghc-exactprint
users</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org65dc4fe">
<h2 id="org65dc4fe">Problem Being Solved</h2>
<p>
To allow a tool to
</p>
<ul>
<li>start from a <code class="src src-haskell"><span style="color: #228b22;">GHC</span> <span style="color: #228b22;">ParsedSource</span></code>,</li>
<li>make changes to it,</li>
<li>print source reflecting the changes.</li>

</ul>

<aside class="notes">
<ul>
<li>And only the changes</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgcf1a517">
<h3 id="orgcf1a517">Start from GHC ParsedSource</h3>
<ul>
<li>It must accurately reflect the input source
<ul>
<li>Literals</li>
<li>‘Trivia’</li>
<li>Spacing</li>

</ul></li>

</ul>

<aside class="notes">
<ul>
<li>To be able to print everything, we need to capture everything</li>
<li>In broad terms the information is Literals, Trivia, which is things like keywords, commas,
semicolons, brackets of all kinds</li>
<li>And of course Spacing.</li>
<li>Let us look at each of these in turn</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org2dffd6d">
<h3 id="org2dffd6d">Literals</h3>
<div class="org-src-container">

<pre class="fragment appear">1, 0x01, 001, 0_01
</pre>
</div>

<div class="org-src-container">

<pre class="fragment appear"><span style="color: #4169e1;">{-# Language CPP #-}</span>
<span style="color: #4169e1;">{-# LANGUAGE CPP #-}</span>
</pre>
</div>

<aside class="notes">
<ul>
<li>Take parsing a simple integer constant, value 1.</li>
<li>&lt;NEXT&gt;
<ul>
<li>These are some of the ways it can be written.</li>

</ul></li>
<li>Or a pragma.</li>
<li>&lt;NEXT&gt;</li>
<li>So we have to keep the as-written text for all of these.</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org355bfe4">
<h3 id="org355bfe4">Trivia</h3>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">let</span>
   <span style="color: #b22222;">-- </span><span style="color: #b22222;">a comment</span>
   fa <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span>
   fa <span style="color: #a0522d;">=</span> 1
<span style="color: #a020f0;">in</span> fa
</pre>
</div>

<aside class="notes">
<ul>
<li>Trivia is everything that does not make it into the AST</li>
<li>Here is a fragment of code for a let expression.</li>
<li>Trivia is `let`, comment, `::`, `=`, `in`</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org29bea27">
<h3 id="org29bea27">Spacing</h3>
<aside class="notes">
<ul>
<li>Like time stops everything happening all at once, space stops it all
from being in the same place</li>
<li>On the face of it it seems simple</li>
<li>To reproduce the original code, we just use the SrcSpan locations</li>
<li><p>
But when you want to change things it gets complicated
</p>
<ul>
<li>Add or delete lines</li>
<li>Move a block of code from one place to another</li>

</ul>
<p>
&lt;NEXT&gt;
</p></li>

</ul>

</aside>

</section>
<section id="slide-orgf06e21f">
<h4 id="orgf06e21f">Principle for Spacing</h4>
<p>
A located AST element is treated as a self-contained unit
</p>
<ul>
<li class="fragment appear">From the inside
<ul>
<li>It is located, so it has a span</li>
<li>Everything we need to print it is inside the located element</li>
<li>Nothing is printed outside its span</li>

</ul></li>
<li class="fragment appear">From the outside
<ul>
<li>We trust its span start point</li>
<li>We trust its span end point</li>

</ul></li>

</ul>

<aside class="notes">
<ul>
<li>So we have a principle for spacing</li>
<li>We apply this principle to be able to change and print an ast.</li>
<li>&lt;READ SLIDE&gt;</li>
<li>&lt;NEXT&gt;</li>
<li>when we are inside the fragment, we have everything we need to be
able to print it.</li>
<li>we can print it based only on what is inside</li>
<li>&lt;NEXT&gt;</li>
<li>I will explain what this trust means shortly</li>

</ul>

</aside>

</section>
<section id="slide-org5ed1aea">
<h4 id="org5ed1aea">Spacing : printing</h4>
<ul>
<li>A self-contained AST element has absolute locations</li>
<li>When we print, we have a print head that we advance</li>
<li>By distances calculated from the absolute locations</li>

</ul>
<aside class="notes">
<p>
But first, lets look at printing an unchanged ast
</p>
<ul>
<li>&lt;READ SLIDE&gt;</li>
<li>We don't print at an absolute location. We move to a place, and then
print.</li>
<li>So, we track two locations
<ul>
<li>The output print position, which always advances as we print</li>
<li>The offset calculation position, which we reset every time we
enter or exit a span
<ul>
<li>(remember “we trust the start and end positions of a span”)</li>

</ul></li>
<li>Otherwise it also advances as we print</li>

</ul></li>
<li>For an unmodified AST these are always perfectly in sync</li>

</ul>

</aside>

</section>
<section id="slide-org6713056">
<h4 id="org6713056">Spacing example</h4>

<div id="org6187112" class="figure">
<p><img src="./images-work/let-in-boxes-raw.png" alt="let-in-boxes-raw.png" />
</p>
</div>
<aside class="notes">
<p>
Here is our let expression again
</p>

</aside>

</section>
<section id="slide-org941d27d">
<h4 id="org941d27d">Spacing example: top box</h4>

<div id="org356c206" class="figure">
<p><img src="./images-work/let-in-boxes-top.png" alt="let-in-boxes-top.png" />
</p>
</div>

<aside class="notes">
<p>
At the top level, it is wrapped in a SrcSpan, setting its start and end position
</p>

</aside>
</section>
<section id="slide-org2da91db">
<h4 id="org2da91db">Spacing example: interior boxes</h4>

<div id="org4d7578c" class="figure">
<p><img src="./images-work/let-in-boxes-middle.png" alt="let-in-boxes-middle.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>If we go into the box, we find 4 more</li>
<li>Two are trivia, two are more boxes we could go into</li>

</ul>

</aside>
</section>
<section id="slide-org8dd0d47">
<h4 id="org8dd0d47">Spacing example: spacing</h4>

<div id="orgdf08e2f" class="figure">
<p><img src="./images-work/let-in-boxes-spacing.png" alt="let-in-boxes-spacing.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>We use distance from the end of one span to the start of the next to
work out how much space to emit when printing</li>
<li>And we trust the start and end span locations, in the sense that we
use them for these calculations</li>

</ul>

</aside>
</section>
<section id="slide-org8f8f124">
<h4 id="org8f8f124">Spacing size changes example</h4>

<div id="org52f2acf" class="figure">
<p><img src="./images-work/let-in-longer-boxes-raw.png" alt="let-in-longer-boxes-raw.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>Say we want to rename `fa` to `falonger`, and just update the
literal text in the AST
<ul>
<li>(for each appropriate `HsVar`)</li>

</ul></li>
<li>But we make no other changes</li>

</ul>

</aside>

</section>
<section id="slide-org1888766">
<h4 id="org1888766">Spacing size changes example: spacing</h4>

<div id="orgf8f5cb0" class="figure">
<p><img src="./images-work/let-in-longer-boxes-spacing.png" alt="let-in-longer-boxes-spacing.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>It's hard to draw this, but imagine the blue boxes are the same ones
from before, not changed for the longer insides</li>
<li>The spacing calculation to the start point is unchanged, so all is
good</li>
<li>When we finish, we set the offset calculation position to the end of the span
(We trust the end position, and have an independent output head)</li>
<li>And so following spacing calculations are unaffected.</li>

</ul>

</aside>

</section>
<section id="slide-org64e93aa">
<h4 id="org64e93aa">Spacing : size changes 2</h4>
<ul>
<li>The same principle holds for bigger changes.</li>
<li>If we change content inside a span, it does not matter,</li>
<li>The “contract” with the surroundings is
<ul>
<li>the start of the span for entry spacing</li>
<li>and the end of the span for exit spacing</li>

</ul></li>

</ul>

</section>
<section id="slide-orgccaedef">
<h4 id="orgccaedef">Spacing : the missing piece</h4>
<ul>
<li class="fragment appear">How do we change things?</li>
<li class="fragment appear">Deltas : Directly provide the spacing</li>

</ul>

<aside class="notes">
<p>
There is one remaining problem
</p>
<ul>
<li>&lt;NEXT&gt;</li>
<li><p>
How do we change things?
</p>
<ul>
<li>If we delete a piece, there will be a gap</li>
<li>If we add something, there will be some kind of jump</li>

</ul>
<p>
&lt;NEXT&gt;
</p></li>
<li>Deltas
<ul>
<li>when we print we have an output head, and all we
need to know is how far to move before printing again.</li>
<li>At the point where we change from one self contained point
to a changed one, we supply the delta directly</li>
<li>Instead of calculating it from the offset calculation position.</li>
<li>And then set the offset calculation position according to the next
actual span we see</li>
<li>We trust the start position in a span</li>
<li>It will come after a delta, so the spacing is known</li>

</ul></li>

</ul>

</aside>

</section>
<section id="slide-org662103e">
<h4 id="org662103e">Spacing : deltas</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">DeltaPos</span>
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">SameLine</span> { deltaColumn <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> }
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">DifferentLine</span> { deltaLine <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span>, deltaColumn <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> }
</pre>
</div>

<aside class="notes">
<ul>
<li>The red arrows we saw before map onto a `DeltaPos`, which can have
line/col</li>
<li>Haskell is a layout-sensitive language</li>
<li>Our print offset position also tracks the current indentation level, so
the <code class="src src-haskell">deltaColumn</code> is added to that.</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org11fdc56">
<h3 id="org11fdc56">Ordering things</h3>
<ul>
<li><code class="src src-haskell"><span style="color: #228b22;">ParsedSource</span></code> is not a completely accurate reflection of the original source.</li>
<li><code class="src src-haskell"><span style="color: #228b22;">ValBinds</span></code> separates out <code class="src src-haskell">[<span style="color: #228b22;">Sig</span>]</code>  and <code class="src src-haskell">[<span style="color: #228b22;">Bind</span>]</code></li>
<li><code class="src src-haskell"><span style="color: #228b22;">ClassDecl</span></code> and <code class="src src-haskell"><span style="color: #228b22;">ClsInstDecl</span></code> separate out <code class="src src-haskell"><span style="color: #228b22;">Bind</span></code>s,
<code class="src src-haskell"><span style="color: #228b22;">Sig</span></code>s, Type family instances etc</li>
<li>For all of these, the original source can have them in any order.</li>

</ul>

<aside class="notes">
<p>
Our next problem is how to order things
</p>

</aside>

</section>
<section id="slide-org1151ecf">
<h4 id="org1151ecf">Ordering things 2</h4>
<ul>
<li>For an unmodified AST there is no problem, you just sort by start of
span.</li>
<li>But a modified one may have rearranged the existing ones, or brought
in ones from elsewhere.</li>
<li>And may have adjusted the spacing with explicit deltas.</li>

</ul>

<aside class="notes">
<ul>
<li>There are some more wrinkles.</li>
<li>&lt;READ SLIDE&gt;</li>
<li>And so just sorting is not an option for printing a changed AST</li>

</ul>

</aside>

</section>
<section id="slide-orged91089">
<h4 id="orged91089">Ordering things 3</h4>

<div id="orgf23412b" class="figure">
<p><img src="./images-work/ordering-smaller.png" alt="ordering-smaller.png" />
</p>
</div>

<div id="orge1db6cf" class="figure">
<p><img src="./images-work/ordering-sortkey-smaller.png" alt="ordering-sortkey-smaller.png" class="fragment" />
</p>
</div>

<aside class="notes">
<ul>
<li>Here is an example, of valbinds with two sigs and two binds</li>
<li>Each specific list is physically ordered, so for <code class="src src-haskell"><span style="color: #228b22;">ValBinds</span></code> we know
the order of the sigs, and of the binds.</li>
<li>But we don’t know the interleaving if we cant use <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code>s</li>
<li>&lt;NEXT&gt;</li>
<li>If so, in addition to the lists of binds and sigs we store a list of
tags</li>
<li>We print according to these, driving a merge
<ul>
<li>so we draw first from the signatures, then the binds, and same
again.</li>

</ul></li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgddc02a4">
<h3 id="orgddc02a4">Comments</h3>
<ul>
<li>Comments are the ultimate “trivia”. They have no influence on
overall spacing and layout, but need to be preserved precisely.</li>
<li>They can also occur absolutely anywhere in the source file.</li>
<li>So we keep them in the "<code>SrcSpan</code> on steroids" we wrap
everything in, and fit them in when we print, if they fit into the
current gap.</li>

</ul>

<aside class="notes">
<ul>
<li>&lt;READ SLIDE&gt;</li>
<li>It’s more complicated than that, but we don't have time to look into
the full detail today</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org5e223a2">
<h3 id="org5e223a2">Trailing Items</h3>

<div id="orgcbb0d1f" class="figure">
<p><img src="./images-work/do-trailing-boxes.png" alt="do-trailing-boxes.png" />
</p>
</div>

<aside class="notes">
<ul>
<li>The final item in this section</li>
<li>The image shows a trailing semi, with a red link to the preceding declaration</li>
<li>The ast can be seen as an assembly of nested, ordered, self-contained boxes.</li>
<li>The self-contained principle says that everything fits inside the
AST Element span.</li>
<li>So trailing items cannot be in the span, but are associated with it.</li>
<li>If you consider a list of items, each item is a standalone entity</li>
<li>The semis exist as part of the surrounding structure.</li>
<li>So if you move the item elsewhere, or replace it with something
else, the trailing semi should be managed as part of that location.</li>
<li>Other trailing items are commas in tuples, vertical bars in data
definitions, single and double arrows in type signatures</li>
<li>We will see how this loose attachment is managed later</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orga64a072">
<h3 id="orga64a072">End of Hand Wavy Part</h3>
<p class="fragment appear">
Questions?
</p>

<aside class="notes">
<ul>
<li>Hopefully you now have a high level understanding of what the exact
print annotations are for</li>
<li>Next we can look into some details of how things are captured in GHC</li>
<li>But first, any questions?</li>
<li>&lt;NEXT&gt;</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgc41c286">
<h2 id="orgc41c286">What it means inside GHC</h2>
<ul>
<li>Located things</li>
<li>Internal Annotations</li>

</ul>

<aside class="notes">
<ul>
<li>Time to dive into the detail.</li>
<li>There are two main divisions</li>
<li>Located things</li>
<li>Internal things</li>
<li>the AST consists of a nested interleaving of located things, so
pretty much every ast element has a location and the thing itself</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org2b73b9f">
<h3 id="org2b73b9f">Terminology</h3>
<ul>
<li>AST means <code class="src src-haskell"><span style="color: #228b22;">ParsedSource</span></code></li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">ParsedSource</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Located</span> (<span style="color: #228b22;">HsModule</span> <span style="color: #228b22;">GhcPs</span>)
</pre>
</div>

<p>
For now we accept <code class="src src-haskell"><span style="color: #228b22;">GhcPs</span></code> as simply a marker of the AST from the
parsing phase.
</p>

<aside class="notes">
<p>
But first some terminology
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org43cae3f">
<h3 id="org43cae3f">Located Things</h3>
<aside class="notes">
<ul>
<li>As I said, the AST is layered, as we saw in the boxes diagrams
earlier.</li>
<li>The types around location are a bit complex, being driven mainly by
type families.</li>
<li>My mental model is that a type family is a function from types to types.</li>
<li>Lets start with the first one
&lt;NEXT&gt;</li>

</ul>

</aside>

</section>
<section id="slide-org8ed6808">
<h4 id="org8ed6808">Location</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">XRec</span> p a <span style="color: #a0522d;">=</span> r <span style="color: #a0522d;">|</span> r <span style="color: #a0522d;">-&gt;</span> a
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">Anno</span> a <span style="color: #a0522d;">=</span> b
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">XRec</span> (<span style="color: #228b22;">GhcPass</span> p) a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> (<span style="color: #228b22;">Anno</span> a) a
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">GhcPs</span>   <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GhcPass</span> '<span style="color: #228b22;">Parsed</span>
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">LHsExpr</span> p <span style="color: #a0522d;">=</span> <span style="color: #228b22;">XRec</span> p (<span style="color: #228b22;">HsExpr</span> p)
<span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Anno</span> (<span style="color: #228b22;">HsExpr</span> (<span style="color: #228b22;">GhcPass</span> p)) <span style="color: #a0522d;">=</span> <span style="color: #228b22;">SrcSpanAnnA</span>
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">SrcSpanAnnA</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpAnn</span> <span style="color: #228b22;">AnnListItem</span>
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">LHsExpr</span> <span style="color: #228b22;">GhcPs</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> (<span style="color: #228b22;">EpAnn</span> <span style="color: #228b22;">AnnListItem</span>) (<span style="color: #228b22;">HsExpr</span> <span style="color: #228b22;">GhcPs</span>)
</pre>
</div>

<aside class="notes">
<ul>
<li>XRec has a parameter p, and maps a type 'a' to a type 'r', and fundeps say the reverse holds too.</li>
<li>`p` is a parameter that is chased through the entire AST, and for `ParsedSource` is always `GhcPs`</li>
<li>&lt;NEXT&gt;</li>
<li>Anno is a type function from `a` to `b`</li>
<li>&lt;NEXT&gt;</li>
<li>We create an instance (= mapping) of XRec for all GhcPass types for
<code class="src src-haskell">a</code> as being located by <code class="src src-haskell"><span style="color: #228b22;">Anno</span> a</code></li>
<li>In our case we use <code class="src src-haskell"><span style="color: #228b22;">GhcPass</span> <span style="color: #228b22;">Parsed</span></code>, as <code class="src src-haskell"><span style="color: #228b22;">GhcPs</span></code></li>
<li>Lets make this concrete</li>
<li>&lt;NEXT&gt;</li>
<li>LHsExpr is defined as an XRec type</li>
<li>And it's Anno instance is SrcSpanAnnA</li>
<li>which in turn is this EpAnn AnnListItem</li>
<li>&lt;NEXT&gt;</li>
<li>So in effect, we have &#x2026;</li>

</ul>

</aside>

</section>
<section id="slide-orge611fa2">
<h4 id="orge611fa2">EpAnn</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpAnn</span> ann <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpAnn</span>
         { entry    <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">Anchor</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">basically SrcSpan when parsed</span>
         , anns     <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>ann
         , comments <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">EpAnnComments</span>
         }
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">Anchor</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaLocation</span>
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">EpaLocation</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaLocation'</span> [<span style="color: #228b22;">LEpaComment</span>]
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpaLocation'</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaSpan</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">SrcSpan</span>
                    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">EpaDelta</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">DeltaPos</span> <span style="color: #a0522d;">!</span>a
</pre>
</div>

<aside class="notes">
<ul>
<li>We are nearly at the bottom</li>
<li><code class="src src-haskell"><span style="color: #228b22;">EpAnn</span></code> is basically an augmented <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code></li>
<li>since the <code class="src src-haskell">entry</code> field carries a <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code> when parsed</li>
<li>`ann` is the parameterised type,  <code class="src src-haskell"><span style="color: #228b22;">AnnListItem</span></code> in our example</li>
<li>`comments` captures any comments included in the immediate
descendents of the thing being located by this, between the sub
boxes in the first section.</li>
<li>&lt;NEXT&gt;</li>
<li>As I said, the as-parsed EpaLocation is EpaSpan, holding a SrcSpan</li>
<li>EpaDelta is used for editing and reprinting, we will deal with it in
the next section.</li>
<li>You will notice a delta also has comments. This is because we can't
sort anything, with deltas, so for trivia having preceding comments
we put them here.</li>

</ul>

</aside>

</section>
<section id="slide-org614ac4b">
<h4 id="org614ac4b"><code class="src src-haskell"><span style="color: #228b22;">AnnListItem</span></code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #8b2252;">-- | Annotation for items appearing in a list. They can have one or</span>
<span style="color: #8b2252;">-- more trailing punctuations items, such as commas or semicolons.</span>
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">AnnListItem</span>
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AnnListItem</span> {
      lann_trailing  <span style="color: #a0522d;">::</span> [<span style="color: #228b22;">TrailingAnn</span>]
      }
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">TrailingAnn</span>
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AddSemiAnn</span>    { ta_location <span style="color: #a0522d;">::</span> <span style="color: #228b22;">EpaLocation</span> }  <span style="color: #8b2252;">-- ^ Trailing ';'</span>
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AddCommaAnn</span>   { ta_location <span style="color: #a0522d;">::</span> <span style="color: #228b22;">EpaLocation</span> }  <span style="color: #8b2252;">-- ^ Trailing ','</span>
<span style="color: #a0522d;">..</span>
</pre>
</div>

<aside class="notes">
<ul>
<li>A <code class="src src-haskell"><span style="color: #228b22;">TrailingAnn</span></code> is an enumeration of a kind of trailing
item and its <code class="src src-haskell"><span style="color: #228b22;">EpaLocation</span></code>
<ul>
<li>So semicolon, comma, arrow, darrow, and vertical bar</li>

</ul></li>
<li>we saw them in the previous section, a semicolon</li>
<li>And this is how we do the "loose attachement" of trailing anns.</li>

</ul>

</aside>

</section>
<section id="slide-org02f1a37">
<h4 id="org02f1a37">Sanity check</h4>
<pre class="example" id="org3172b34">
(L
 (EpAnn
  (EpaSpan { DumpParsedAst.hs:5:1-16 })
  (AnnListItem
   [])
  (EpaComments
   []))
   ...
</pre>


<aside class="notes">
<ul>
<li>This is what a dump of an AST using this location type looks like,
from a GHC test</li>
<li>After this deep dive into types, let's come up for air a bit.</li>
<li>If you recall in the handwavy part we spoke about span being the
source of truth, the thing we trust.</li>
<li><code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code> we trust is the one in the <code class="src src-haskell"><span style="color: #228b22;">EpAnn</span> entry</code>, using the
<code class="src src-haskell"><span style="color: #228b22;">EpaSpan</span></code> constructor.</li>
<li>If we need to move things around, the surgery happens by replacing
it with an appropriate <code class="src src-haskell"><span style="color: #228b22;">EpaDelta</span></code> version, just for the
point where the change happens, and maybe the immediately following one</li>
<li>For ghc-exactprint old hands, <code class="src src-haskell">makeDeltaAst</code> is no longer required (but still exists)</li>
<li>Next we look at the storage of internal annotations</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org40532a8">
<h3 id="org40532a8">Internal Annotations</h3>
<ul>
<li><code class="src src-haskell"><span style="color: #228b22;">SourceText</span></code> for Literals,</li>
<li>keywords (via <code class="src src-haskell"><span style="color: #228b22;">AnnKeywordId</span></code> or <code class="src src-haskell"><span style="color: #228b22;">EpToken</span></code>)</li>

</ul>

<aside class="notes">
<ul>
<li>everything that is not a location, comment, or surrounding
information, but is needed for exact printing.</li>
<li>SourceText keeps the as-written source text of a literal, so it can
be used when printing.</li>
<li>keywords or trivia are all the other punctuation marks.
<ul>
<li>When not in a trailing usage.</li>

</ul></li>
<li>Comments are also stored in the <code class="src src-haskell"><span style="color: #228b22;">Located</span></code> part now</li>

</ul>

</aside>

</section>
<section id="slide-orgad77f6f">
<h4 id="orgad77f6f"><code class="src src-haskell"><span style="color: #228b22;">AnnKeywordId</span></code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">AnnKeywordId</span>
    <span style="color: #a0522d;">...</span>
    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AnnIn</span>
    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AnnLet</span>
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">AddEpAnn</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AddEpAnn</span> <span style="color: #228b22;">AnnKeywordId</span> <span style="color: #228b22;">EpaLocation</span>
</pre>
</div>

<aside class="notes">
<ul>
<li>This is the original mechanism for capturing keywords.</li>
<li>It is an enumeration of what it is, together with its location.</li>
<li>It tells us what to print, where</li>

</ul>

</aside>

</section>
<section id="slide-org41b47ec">
<h4 id="org41b47ec"><code class="src src-haskell"><span style="color: #228b22;">EpToken</span></code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpToken</span> (tok <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Symbol</span>)
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">NoEpTok</span>
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">EpTok</span> <span style="color: #a0522d;">!</span><span style="color: #228b22;">EpaLocation</span>
</pre>
</div>

<p>
Used as a type: <code class="src src-haskell"><span style="color: #228b22;">EpTok</span> <span style="color: #8b2252;">"let"</span></code>
</p>

<div class="org-src-container">

<pre class="fragment"><span style="color: #b22222;">-- </span><span style="color: #b22222;">Extract string for printing</span>
<span style="color: #0000ff;">getEpTokenString</span> <span style="color: #a0522d;">::</span> <span style="color: #a020f0;">forall</span> tok<span style="color: #a0522d;">.</span> <span style="color: #228b22;">KnownSymbol</span> tok <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">EpToken</span> tok <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Maybe</span> <span style="color: #228b22;">String</span>
<span style="color: #0000ff;">getEpTokenString</span> <span style="color: #228b22;">NoEpTok</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Nothing</span>
<span style="color: #0000ff;">getEpTokenString</span> (<span style="color: #228b22;">EpTok</span> <span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Just</span> <span style="color: #a0522d;">$</span> symbolVal (<span style="color: #228b22;">Proxy</span> <span style="color: #a0522d;">@</span>tok)
</pre>
</div>

<aside class="notes">
<ul>
<li>This is the new mechanism. It ie likely to supplant
<code class="src src-haskell"><span style="color: #228b22;">AddEpAnn</span></code> and <code class="src src-haskell"><span style="color: #228b22;">AnnKeywordId</span></code></li>
<li>Apart from <code class="src src-haskell"><span style="color: #228b22;">NoEpTok</span></code>, this is isomorphic to
<code class="src src-haskell"><span style="color: #228b22;">AddEpAnn</span></code>, in that it tells us what to print, and where</li>
<li>&lt;NEXT&gt;</li>
<li>And this shows you how to get the "let" back out for the example</li>

</ul>

</aside>

</section>
<section id="slide-org7554be7">
<h4 id="org7554be7">Internal Annotation storage</h4>
<aside class="notes">
<p>
Back into type function land, as we look into how these keywords are
stored in an AST element.
</p>

</aside>

</section>
<section id="slide-orgf0911d8">
<h4 id="orgf0911d8">Trees That Grow</h4>
<ul>
<li>GHC AST implements “Trees That Grow”</li>
<li>This means extra information can be carried, computed via type classes</li>
<li>We call them "Extension points"</li>

</ul>

</section>
<section id="slide-orgbdccb8d">
<h4 id="orgbdccb8d">Refresher</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">HsExpr</span> p
  <span style="color: #a0522d;">...</span>
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">HsLet</span> (<span style="color: #228b22;">XLet</span> p) (<span style="color: #228b22;">HsLocalBinds</span> p) (<span style="color: #228b22;">LHsExpr</span>  p)

<span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">XLet</span> x
</pre>
</div>
<div class="org-src-container">

<pre class="fragment"><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">XLet</span> <span style="color: #228b22;">GhcPs</span> <span style="color: #a0522d;">=</span> (<span style="color: #228b22;">EpToken</span> <span style="color: #8b2252;">"let"</span>, <span style="color: #228b22;">EpToken</span> <span style="color: #8b2252;">"in"</span>)
</pre>
</div>

<div id="orgccbd527" class="figure">
<p><img src="./images-work/let-in-boxes-middle-smaller.png" alt="let-in-boxes-middle-smaller.png" class="fragment" />
</p>
</div>
<aside class="notes">
<ul>
<li>Every constructor in the GHC AST has a first field named something
like XLet for HsLet constructor</li>
<li>It is parameterised by the global AST parameter p,
<code class="src src-haskell"><span style="color: #228b22;">GhcPs</span></code> for us</li>
<li>And there is a type family for it, so instances can be defined to
map it onto a concrete type.</li>
<li>&lt;NEXT&gt;</li>
<li>For XLet and GhcPs this is a tuple for a let and an in <code class="src src-haskell"><span style="color: #228b22;">EpToken</span></code></li>
<li>&lt;NEXT&gt;</li>
<li>Going back to our example, these capture the locations in violet</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org059b84f">
<h3 id="org059b84f">Recap</h3>
<p class="fragment appear">
Questions?
</p>

<aside class="notes">
<p>
This section has scratched the surface. There is a lot more I have not covered, e.g.
</p>
<ul>
<li><code class="src src-haskell"><span style="color: #228b22;">LocatedN</span> <span style="color: #228b22;">RdrName</span></code></li>
<li>Annotations around lists, context, pragmas and so on</li>
<li>But we will now look at how we use it for its intended purpose,
tools to change and emit updated source.</li>
<li>Recall my original motivation was the haskell refactorer</li>
<li>But first, any questions?</li>
<li>&lt;NEXT&gt;</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orga5dc366">
<h2 id="orga5dc366">What it means outside GHC</h2>
<ul>
<li>The Exact Print Annotations are packaged for use in <a href="https://hackage.haskell.org/package/ghc-exactprint">ghc-exactprint</a></li>
<li>Generally a "hidden" library, enabling others
<ul>
<li>hlint apply hints</li>
<li>various plugins in HLS</li>
<li>retrie</li>
<li>built for HaRe, but that now languishes</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org1e771d8">
<h3 id="org1e771d8">ghc-exactprint big picture</h3>
<ul>
<li>Parse</li>
<li>Transform</li>
<li>Print</li>

</ul>

<aside class="notes">
<ul>
<li>The usual thing. input, process, output.</li>
<li>Lets look at each in turn</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org0534a46">
<h3 id="org0534a46">ghc-exactprint parsing</h3>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GHC.DynFlags</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">FilePath</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">ParseResult</span> a
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #0000ff;">parseExpr</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> (<span style="color: #228b22;">GHC.LHsExpr</span> <span style="color: #228b22;">GHC.GhcPs</span>)
<span style="color: #0000ff;">parseImport</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> (<span style="color: #228b22;">GHC.LImportDecl</span> <span style="color: #228b22;">GHC.GhcPs</span>)
<span style="color: #0000ff;">parseType</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> (<span style="color: #228b22;">GHC.LHsType</span> <span style="color: #228b22;">GHC.GhcPs</span>)
<span style="color: #0000ff;">parseDecl</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> (<span style="color: #228b22;">GHC.LHsDecl</span> <span style="color: #228b22;">GHC.GhcPs</span>)
<span style="color: #0000ff;">parseStmt</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> (<span style="color: #228b22;">GHC.ExprLStmt</span> <span style="color: #228b22;">GHC.GhcPs</span>)
<span style="color: #0000ff;">parsePattern</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> (<span style="color: #228b22;">GHC.LPat</span> <span style="color: #228b22;">GHC.GhcPs</span>)
</pre>
</div>

<aside class="notes">
<ul>
<li>This is a wrapper around the GHC parser</li>
<li><p>
a pure function
</p>
<ul>
<li>there are helpers to build appropriate <code class="src src-haskell"><span style="color: #228b22;">DynFlags</span></code></li>
<li>FilePath is used just for SrcSpan construction</li>
<li>String is the source</li>

</ul>
<p>
&lt;NEXT&gt;
</p></li>
<li>We have ones for various subcomponents</li>
<li>They are an option for constructing fragments to be inserted into an
existing AST somewhere</li>

</ul>

</aside>

</section>
<section id="slide-orgdf48dc8">
<h4 id="orgdf48dc8">ghc-exactprint parseModule</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">parseModule</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">LibDir</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">FilePath</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">IO</span> (<span style="color: #228b22;">ParseResult</span> <span style="color: #228b22;">GHC.ParsedSource</span>)
</pre>
</div>

<aside class="notes">
<ul>
<li>This is the main one used when actually changing a module</li>
<li><code class="src src-haskell"><span style="color: #228b22;">LibDir</span></code> is where the GHC being used is installed. It can
be retrieved using the <a href="https://hackage.haskell.org/package/ghc-paths">ghc-paths</a> package</li>
<li>"best effort" with CPP
<ul>
<li>compares original with preprocessed, and turns the diff into
comments</li>
<li>cannot work if <code>#define XX Blah</code> and then <code>XX</code> is used. <code>XX</code> added as a comment, as well as <code>Blah</code></li>

</ul></li>
<li>Honours pragmas, but you need to set <code class="src src-haskell"><span style="color: #228b22;">DynFlags</span></code> for any e.g. project-wide options</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgaafafc3">
<h3 id="orgaafafc3">ghc-exactprint transform</h3>
<aside class="notes">
<ul>
<li>This is the "process" step after parsing the input</li>
<li>It is the reason we have <code class="src src-haskell">ghc<span style="color: #0000ff;">-</span>exactprint</code> and the exact
print annotations in GHC</li>
<li>Intention: allow the smallest changes possible, when applying a
change to the AST</li>
<li>But first lets go off at a tangent</li>

</ul>

</aside>

</section>
<section id="slide-org0ab0b3a">
<h4 id="org0ab0b3a">Comments</h4>
<p>
Stored in <code class="src src-haskell"><span style="color: #228b22;">EpAnn</span></code>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">EpAnnComments</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EpaComments</span>
                        { priorComments <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>[<span style="color: #228b22;">LEpaComment</span>] }
                   <span style="color: #a0522d;">|</span> <span style="color: #228b22;">EpaCommentsBalanced</span>
                        { priorComments     <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>[<span style="color: #228b22;">LEpaComment</span>]
                        , followingComments <span style="color: #a0522d;">::</span> <span style="color: #a0522d;">!</span>[<span style="color: #228b22;">LEpaComment</span>] }
</pre>
</div>

<aside class="notes">
<ul>
<li>Lets talk about comments</li>
<li><code class="src src-haskell"><span style="color: #228b22;">EpAnn</span></code> is the "super <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code>" we use for locations</li>
<li>The initial parsing is optimised for speed, you are not necessarily
going to change things</li>
<li>Once you decide to move thing around, you need to decide which
comments to bring along.</li>
<li>The comments constructors initially carry <code class="src src-haskell">priorComments</code> only, which
precede the given declarations.</li>

</ul>

</aside>

</section>
<section id="slide-orga7c3a43">
<h4 id="orga7c3a43"><code class="src src-haskell">balanceComments</code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>


<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> 3
<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">bar</span> <span style="color: #a0522d;">=</span> 2
</pre>
</div>

<aside class="notes">
<ul>
<li><code>ghc-exactprint</code> has <code class="src src-haskell">balanceComments</code> and <code class="src src-haskell">balanceCommentsList</code></li>
<li>These use heuristics to "attach" comments to the appropriate
declaration in a list</li>
<li>Here is some example source.  When we balance comments</li>

</ul>

</aside>

</section>
<section id="slide-orgdb70173">
<h4 id="orgdb70173">becomes</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> 3
<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">bar</span> <span style="color: #a0522d;">=</span> 2
</pre>
</div>

<aside class="notes">
<ul>
<li>The first comment is attached to the module header. Or to the first
declaration if it is a lower level list</li>
<li>The next two become prior and following comments for foo.</li>
<li>following comments are kept if they immediately follow a declaration.</li>
<li>And the last two become prior comments for bar.</li>
<li>This makes a given list of declarations ready for modification.
<ul>
<li>You can take one and move it somewhere else, or insert a new one
in between, and hopefully the comments will still make sense.</li>

</ul></li>

</ul>

</aside>

</section>
<section id="slide-org6853a3d">
<h4 id="org6853a3d"><code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> comments</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>


<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #228b22;">True</span> <span style="color: #a0522d;">=</span> 3
<span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">=</span> 2
<span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing second fun</span>
</pre>
</div>

<aside class="notes">
<ul>
<li><code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> is weird</li>
<li>it combines all the equations for a particular function</li>
<li>each shows up as a <code class="src src-haskell"><span style="color: #228b22;">Match</span></code>, which is self-contained, and
is the original parsed <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> declaration</li>
<li>So we have a similar setup to the previous one, but they are all
part of the same <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code></li>

</ul>

</aside>

</section>
<section id="slide-org9d49df5">
<h4 id="org9d49df5">becomes</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">a random comment</span>
</pre>
</div>

<p>
On FunBind prior comments
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a function</span>
</pre>
</div>

<p>
First match (OOPS, BUG in 1.10.0.0)
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">foo</span> <span style="color: #228b22;">True</span> <span style="color: #a0522d;">=</span> 3
</pre>
</div>

<p>
Second match
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">here is a trailing comment</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">Another random aside</span>

<span style="color: #b22222;">-- </span><span style="color: #b22222;">another function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">=</span> 2
</pre>
</div>

<p>
On FunBind following comments
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing second fun</span>
</pre>
</div>

<aside class="notes">
<ul>
<li>The first comment is as before</li>
<li>Rest are as per the comments</li>
<li>So we have prior and following comments for the funbind as a whole,
at the top level.</li>
<li>And each interior match, bar the first and last, has its own prior
and following comments.</li>

</ul>

</aside>

</section>
<section id="slide-org141d9a0">
<h4 id="org141d9a0">Produced by</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">test</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">TestList</span> [mkTestModChange libdir balanceComments <span style="color: #8b2252;">"AFile.hs"</span>]

<span style="color: #0000ff;">balanceComments</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">LibDir</span> <span style="color: #a0522d;">-&gt;</span> (<span style="color: #228b22;">ParsedSource</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">IO</span> <span style="color: #228b22;">ParsedSource</span>)
<span style="color: #0000ff;">balanceComments</span> _libdir lp <span style="color: #a0522d;">=</span> return <span style="color: #a0522d;">$</span> replaceDecls lp ds'
  <span style="color: #a020f0;">where</span>
    ds <span style="color: #a0522d;">=</span> hsDecls lp
    ds' <span style="color: #a0522d;">=</span> balanceCommentsList ds
</pre>
</div>

<aside class="notes">
<ul>
<li>This is a function that changes a GHC ParsedSource</li>
<li>It gets a LibDir in case we want to parse a new fragment for insertion</li>
<li>You will notice that in addition to balanceCommentsList, it uses
<ul>
<li>hsDecls and replaceDecls.</li>
<li>We will talk about them next</li>

</ul></li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgf907a52">
<h3 id="orgf907a52"><code class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">HasDecls</span></code></h3>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">class</span> (<span style="color: #228b22;">Data</span> t) <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">HasDecls</span> t <span style="color: #a020f0;">where</span>
    hsDecls <span style="color: #a0522d;">::</span> t <span style="color: #a0522d;">-&gt;</span> [<span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span>]
    replaceDecls <span style="color: #a0522d;">::</span> t <span style="color: #a0522d;">-&gt;</span> [<span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span>] <span style="color: #a0522d;">-&gt;</span> t
</pre>
</div>

<p>
Identity
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">exactPrint</span> x <span style="color: #a0522d;">===</span> exactPrint (replaceDecls x (hsDecls x))
</pre>
</div>

<aside class="notes">
<ul>
<li>hsDecls
<ul>
<li>Return the 'HsDecl's that are directly enclosed in the given
syntax phrase. They are always returned in the wrapped 'HsDecl'
form, even if orginating in local decls. This is safe, as
annotations never attach to the wrapper, only to the wrapped item.</li>

</ul></li>
<li>replaceDecls
<ul>
<li>Replace the directly enclosed decl list by the given decl list. As
part of replacing it will update list order annotations, and
rebalance comments and other layout changes as needed.</li>

</ul></li>
<li>And it should preserve the identity that replacing the decls you
just got should print the same.</li>

</ul>

</aside>

</section>
<section id="slide-org78520f0">
<h4 id="org78520f0"><code class="src src-haskell">replaceDecls</code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #8b2252;">-- |This is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> x <span style="color: #b22222;">-- </span><span style="color: #b22222;">comment1</span>
<span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing comment</span>
</pre>
</div>

<p>
to
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #8b2252;">-- |This is a function</span>
<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">=</span> x <span style="color: #b22222;">-- </span><span style="color: #b22222;">comment1</span>
  <span style="color: #a020f0;">where</span>
    nn <span style="color: #a0522d;">=</span> 2
<span style="color: #b22222;">-- </span><span style="color: #b22222;">trailing comment</span>
</pre>
</div>
<aside class="notes">
<ul>
<li>This is the effect of calling <code class="src src-haskell">replaceDecls</code> on the
specific <code class="src src-hakell">Match</code> of the function <code class="src src-haskell">foo</code></li>
<li>You will notice it inserts the now-needed <code class="src src-haskell"><span style="color: #a020f0;">where</span></code></li>
<li>And does sane things with the comments</li>

</ul>

</aside>

</section>
<section id="slide-orgcb408c7">
<h4 id="orgcb408c7">code for the replace</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">addLocaLDecl1</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Changer</span>
<span style="color: #0000ff;">addLocaLDecl1</span> libdir top <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">do</span>
  <span style="color: #228b22;">Right</span> decl <span style="color: #a0522d;">&lt;-</span> withDynFlags libdir (<span style="color: #a0522d;">\</span>df <span style="color: #a0522d;">-&gt;</span> parseDecl df <span style="color: #8b2252;">"decl"</span> <span style="color: #8b2252;">"nn = 2"</span>)
  <span style="color: #a020f0;">let</span>
      (de1<span style="color: #228b22;">:</span>d2<span style="color: #228b22;">:</span>ds) <span style="color: #a0522d;">=</span> hsDecls top
      (de1',d2') <span style="color: #a0522d;">=</span> balanceComments de1 d2
      (de1'',<span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> modifyValD (getLocA de1') de1' <span style="color: #a0522d;">$</span> <span style="color: #a0522d;">\</span>_m ds <span style="color: #a0522d;">-&gt;</span>
                   (decl <span style="color: #228b22;">:</span> ds, <span style="color: #228b22;">Nothing</span>)
  return <span style="color: #a0522d;">$</span> replaceDecls top (de1''<span style="color: #228b22;">:</span>d2'<span style="color: #228b22;">:</span>ds)
</pre>
</div>

<aside class="notes">
<ul>
<li>We parse a new declaration <code class="src src-haskell"><span style="color: #0000ff;">nn</span> <span style="color: #a0522d;">=</span> 2</code>
<ul>
<li>NOTE: its initial location is ignored, we use the surrounding decl
list context for the starting point.</li>

</ul></li>
<li>Then we get the list of decls, broken into first, next and rest
<ul>
<li>In the source example there is a second function, so we can show
the trailing comments</li>

</ul></li>
<li>we balance comments betwen the first and second declaration</li>
<li>and  call modifyValD to do the work.
<ul>
<li>I will explain more in the next slides,</li>
<li>but the key point is the lambda that receives the existing <code class="src src-haskell"><span style="color: #228b22;">Match</span></code>
local binds in <code class="src src-haskell">ds</code> and prepends <code class="src src-haskell">decl</code> to
them</li>

</ul></li>
<li>And then replace the modified top-level decls</li>
<li>ghc-exactprint old hands will notice that apart from parsing, all
the code is pure</li>

</ul>

</aside>

</section>
<section id="slide-org8cf89bb">
<h4 id="org8cf89bb"><code class="src src-haskell">modifyValD</code></h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a0522d;">..</span>
[ma1,_ma2] <span style="color: #a0522d;">=</span> ms <span style="color: #b22222;">-- </span><span style="color: #b22222;">of de1</span>
(de1',<span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> modifyValD (getLocA ma1) de1 <span style="color: #a0522d;">$</span> <span style="color: #a0522d;">\</span>_m decls <span style="color: #a0522d;">-&gt;</span>
             (newDecl <span style="color: #228b22;">:</span> decls, <span style="color: #228b22;">Nothing</span>)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Decl</span>  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span>
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">PMatch</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">LMatch</span> <span style="color: #228b22;">GhcPs</span> (<span style="color: #228b22;">LHsExpr</span> <span style="color: #228b22;">GhcPs</span>)
<span style="color: #0000ff;">modifyValD</span>
   <span style="color: #a0522d;">::</span> <span style="color: #a020f0;">forall</span> t<span style="color: #a0522d;">.</span>
   <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">SrcSpan</span>
   <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Decl</span>
   <span style="color: #a0522d;">-&gt;</span> (<span style="color: #228b22;">PMatch</span> <span style="color: #a0522d;">-&gt;</span> [<span style="color: #228b22;">Decl</span>] <span style="color: #a0522d;">-&gt;</span> ([<span style="color: #228b22;">Decl</span>], <span style="color: #228b22;">Maybe</span> t))
   <span style="color: #a0522d;">-&gt;</span> (<span style="color: #228b22;">Decl</span>, <span style="color: #228b22;">Maybe</span> t)
</pre>
</div>

<aside class="notes">
<ul>
<li>So lets look at <code class="src src-haskell">modifyValD</code></li>
<li>It modifies a  <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> wrapped in a <code class="src src-haskell"><span style="color: #228b22;">ValD</span></code>.</li>
<li>The supplied <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code> is used to identify the specific
<code class="src src-haskell"><span style="color: #228b22;">Match</span></code> to be transformed, for when there are multiple of
them.</li>
<li>The other parameters are
<ul>
<li>The <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code>, as a <code class="src src-haskell"><span style="color: #228b22;">Decl</span></code>.</li>
<li>A function taking a <code class="src src-haskell"><span style="color: #228b22;">Match</span></code> and a list of its local binds (as <code class="src src-haskell"><span style="color: #228b22;">Decl</span></code>s)
<ul>
<li>And returning updated local binds, and <code class="src src-haskell"><span style="color: #228b22;">Maybe</span></code> whatever</li>

</ul></li>

</ul></li>
<li>And it returns the updated <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> as a <code class="src src-haskell"><span style="color: #228b22;">Decl</span></code></li>
<li>It is a bit janky, no need to return <code class="src src-haskell"><span style="color: #228b22;">Maybe</span> t</code>, user can wrap it in
state if they need it</li>

</ul>

</aside>

</section>
<section id="slide-orgcc7ba4d">
<h4 id="orgcc7ba4d">There is a lot going on under the hood</h4>
<ul>
<li>unpack the <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> for comments</li>
<li>for the specific <code class="src src-haskell"><span style="color: #228b22;">Match</span></code>
<ul>
<li>extract the local binds</li>
<li>sorted according to the <code class="src src-haskell"><span style="color: #228b22;">AnnSortKey</span></code></li>
<li>as decls</li>

</ul></li>
<li>apply the function</li>
<li>when replacing, add or remove <code class="src src-haskell"><span style="color: #a020f0;">where</span></code> if it was empty or becomes empty</li>
<li>update the <code class="src src-haskell"><span style="color: #228b22;">AnnSortKey</span></code></li>
<li>pack the <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> for comments</li>

</ul>

<aside class="notes">
<ul>
<li>We did not go into <code class="src src-haskell"><span style="color: #228b22;">AnnSortKey</span></code>. It stores the tags
giving the merge order.</li>
<li>note: it is up to the user-supplied function to call
<code class="src src-haskell">balanceComments</code> on the provided decls if needed.</li>
<li>I will explain about packing and unpacking funbinds next</li>

</ul>

</aside>

</section>
<section id="slide-org26b7933">
<h4 id="org26b7933">packFunBind, unpackFunBind</h4>
<ul>
<li>unpackFunBind</li>
<li>packFunBind</li>

</ul>

<aside class="notes">
<ul>
<li>As I explained earlier, if we are working with a
<code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> in a list of <code class="src src-haskell"><span style="color: #228b22;">Decl</span></code>s, we need to be
able to work with its prior and following comments, for example to
balance comments</li>
<li>But a <code class="src src-haskell"><span style="color: #228b22;">FunBind</span></code> is just a container for self-contained
<code class="src src-haskell"><span style="color: #228b22;">Match</span></code>es, and those are the things we modify</li>
<li>So <code class="src src-haskell">unpackFunBind</code> takes these <code class="src src-haskell"><span style="color: #228b22;">ValD</span></code> level
prior and following comments and pushes them down to the first and
last <code class="src src-haskell"><span style="color: #228b22;">Match</span></code> respectively</li>
<li>After changes are made to the matches, <code class="src src-haskell">packFunBind</code> does
the reverse</li>

</ul>

</aside>

</section>
<section id="slide-org39d9c90">
<h4 id="org39d9c90">insertAt and friends</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">insertAtStart, insertAtEnd</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">HasDecls</span> ast <span style="color: #a0522d;">=&gt;</span> ast <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span> <span style="color: #a0522d;">-&gt;</span> ast
</pre>
</div>

<div class="org-src-container">

<pre class="fragment"><span style="color: #0000ff;">insertAfter, insertBefore</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">HasDecls</span> (<span style="color: #228b22;">LocatedA</span> ast)
                          <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">LocatedA</span> old
                          <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">LocatedA</span> ast
                          <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">LHsDecl</span> <span style="color: #228b22;">GhcPs</span>
                          <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">LocatedA</span> ast
</pre>
</div>

<aside class="notes">
<ul>
<li>There is another set of utilities, put in by Matt Pickering for the
hlint apply refact integration</li>
<li>Insert a declaration at the <code class="src src-haskell"><span style="color: #0000ff;">beginning</span> or end</code> of the subdecls of the
given AST item having sub-declarations</li>
<li>&lt;NEXT&gt;</li>
<li>Insert a declaration at a <code class="src src-haskell"><span style="color: #0000ff;">specific</span> location</code> in the
subdecls</li>
<li>Note that <code class="src src-haskell">insertBefore</code> and <code class="src src-haskell">insertAfter</code>
will only work on a list of decls without deltas in them
<ul>
<li>Which is fine, for a one-shot change</li>

</ul></li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org8c81056">
<h3 id="org8c81056">ghc-exactprint print</h3>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #0000ff;">exactPrint</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">ExactPrint</span> ast <span style="color: #a0522d;">=&gt;</span> ast <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">String</span>
</pre>
</div>

<aside class="notes">
<ul>
<li>The output stage of "input, process output"</li>
<li>This is the heart of the thing, it accurately reproduces the ast,
with modifications.</li>
<li>But we will not look in detail, it is too complex for the time
allowed</li>
<li>I will be around, can take anyone interested over it</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgb3bad6c">
<h3 id="orgb3bad6c">Name tie-ups</h3>
<ul>
<li>All <code class="src src-haskell"><span style="color: #228b22;">RdrName</span></code>s in the AST are <code class="src src-haskell"><span style="color: #228b22;">LocatedN</span></code>, containing
a <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code> when originally parsed.</li>
<li>The <code class="src src-haskell"><span style="color: #228b22;">RenamedSource</span></code> does not remove named locations,
although it may move them around a bit.</li>
<li>So perform a generic traversal of the <code class="src src-haskell"><span style="color: #228b22;">RenamedSource</span></code>,
building a map of <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Name</span></code></li>

</ul>

<aside class="notes">
<ul>
<li>And now on to some more tangential things, as we head toward wrapping</li>
<li>&lt;READ SLIDE&gt;</li>
<li>This lets you use the Renamer output for the parse source</li>
<li>I am a bit out of the loop at the moment, this functionality may
already exist somewhere</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgdc00f9e">
<h2 id="orgdc00f9e">Future</h2>
<ul>
<li>Fixity info</li>
<li>Free vars?</li>
<li>Easy Export of Name table for lookup?</li>
<li><code class="src src-haskell"><span style="color: #228b22;">GHC_CPP</span></code></li>
<li>ghc-exactprint API
<ul>
<li>currently provisional</li>
<li>should it be split?</li>
<li>where should it live?</li>

</ul></li>
<li>Link-up with ghc-lib-parser</li>

</ul>

<aside class="notes">
<ul>
<li>Here are some things that I think are worth doing around this area</li>
<li>Fixity.
<ul>
<li>The problem is that the ParseSource does not know operator
precedence, so builds a tree giving all operators the same
precedence.</li>
<li>In GHC the tree is re-written in the the Renamer to properly
reflect the actual precedences</li>
<li>And it is vital to work with a rewritten tree.</li>
<li>We have code dealing with it in hlint, retrie, probably a few more.
<ul>
<li>And this is best effort, using known built in fixities</li>

</ul></li>
<li>Solution is
<ul>
<li>put this fixity processing in one place</li>
<li>improve it, be making it available from GHC</li>

</ul></li>

</ul></li>
<li>GHC CPP
<ul>
<li>The ghc-exactprint processing is very poor.</li>
<li>CPP is too powerful, it processes directives in comments, trailing backslashes, etc</li>
<li>I am convinced &gt;90% of usage could be captured with a reduced power option</li>
<li>I have a GHC proposal, intend taking it forward real soon now</li>

</ul></li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org3976b7b">
<h2 id="org3976b7b">GHC 9.10</h2>
<ul>
<li>Sorry for the breakage</li>
<li>Porting/changes at <a href="https://gist.github.com/alanz/e127e7561ddf1cfeb07fbdee9a966794">Exact Print Annotations GHC 9.10 changes</a></li>
<li>TLDR
<ul>
<li>remove <code class="src src-haskell">makeDeltaAst</code>, otherwise there will be no <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code>
anywhere in the AST (but when ready to make a change, using it to
capture spacing of the local thing being edited may help)</li>
<li><code class="src src-haskell"><span style="color: #228b22;">EpAnnNotUsed</span></code> is gone, use <code class="src src-haskell">noAnn</code> instead</li>
<li><code class="src src-haskell">uniqueSrcSpanT</code> is no longer needed, use an appropriate
<code class="src src-haskell"><span style="color: #228b22;">EpaDelta</span></code> location instead</li>
<li><code class="src src-haskell"><span style="color: #228b22;">EpaDelta</span> (<span style="color: #228b22;">DifferentLine</span> row col)</code> interprets <code class="src src-haskell">col</code> differently.
You must add 1 to get the prior spacing.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org76c43e0">
<h2 id="org76c43e0">End</h2>
<p>
This presentation: <a href="https://alanz.github.io/hew2024/">https://alanz.github.io/hew2024/</a>
</p>

<ul>
<li><a href="https://github.com/alanz/ghc-exactprint">https://github.com/alanz/ghc-exactprint</a></li>
<li><a href="https://gist.github.com/alanz/e127e7561ddf1cfeb07fbdee9a966794">Exact Print Annotations GHC 9.10 changes</a></li>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/pull/616">GHC CPP proposal</a></li>
<li>Slides written in emacs <a href="https://orgmode.org/">org-mode</a> using <a href="https://gitlab.com/oer/org-re-reveal">org-re-reveal</a> for <a href="https://revealjs.com/">reveal.js</a></li>

</ul>

<p>
Questions?
</p>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>
<script src="./reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: false,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
totalTime: 3000,
overview: true,

transition: 'linear',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
