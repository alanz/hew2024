<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>ghc-exactprint (HEW 2024)</title>
<meta name="author" content="Alan Zimmerman"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/white_contrast_compact_verbatim_headers.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>

<link rel="stylesheet" href="./reveal.js/plugin/toc-progress/toc-progress.css"/>
<link rel="stylesheet" href="./reveal.js/plugin/highlight/github.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="table-of-contents-section">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#slide-orgccc1358">ghc-exactprint</a></li>
<li><a href="#slide-org8e424cc">About Me</a></li>
<li><a href="#slide-org6413d71">This Talk</a></li>
<li><a href="#slide-orgb614c23">Problem Being Solved</a></li>
<li><a href="#slide-org833a010">What it means inside GHC</a></li>
<li><a href="#slide-orgdf06920">What it means outside GHC</a></li>
<li><a href="#slide-orgb602640">Future</a></li>
<li><a href="#slide-orgc385a7f">GHC 9.10</a></li>
<li><a href="#slide-org06b5ec0">End</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-orgccc1358">
<h2 id="orgccc1358">ghc-exactprint</h2>
<p>
Alan Zimmerman
</p>

<p>
<a href="https://social.coop/@alanz"><code>@alanz@social.coop</code></a>
</p>

<p>
Haskell Ecosystem Workshop,
ZuriHac, 2024-06-07
</p>

</section>
</section>
<section>
<section id="slide-org8e424cc">
<h2 id="org8e424cc">About Me</h2>
<ul>
<li>Learned Haskell in 2012</li>
<li>Decided to resurrect HaRe, using GHC backend</li>
<li>First GHC commit Sep 2014</li>
<li>Led to haskell-ide-engine, to expose it to users</li>
<li>And into GHC to make it useful for this</li>

</ul>

</section>
</section>
<section>
<section id="slide-org6413d71">
<h2 id="org6413d71">This Talk</h2>
<ul>
<li>What is the problem being solved</li>
<li>What it means inside GHC</li>
<li>What it means outside GHC</li>

</ul>

<aside class="notes">
<ul>
<li>Going through material, it is a huge topic, chat to me at ZuriHac</li>
<li>First a Hand-wavy attempt to motivate the problem being solved</li>
<li>Then how we capture the required information inside GHC, aimed at
GHC developers and ghc-exactprint users</li>
<li>Finally how to use the provided facilities in the real world</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgb614c23">
<h2 id="orgb614c23">Problem Being Solved</h2>
<p>
To allow a tool to
</p>
<ul>
<li>start from a <code>GHC</code> <code>ParsedSource</code>,</li>
<li>make changes to it,</li>
<li>print source reflecting the changes.</li>

</ul>
<ul class="fragment">
<li>And only the changes.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgbf7c22c">
<h3 id="orgbf7c22c">Start from GHC ParsedSource</h3>
<ul>
<li>It must accurately reflect the input source
<ul>
<li>Literals</li>
<li>‘Trivia’</li>
<li>Spacing</li>

</ul></li>

</ul>

<aside class="notes">
<ul>
<li>Unless care is taken, information vital to being able to reproduce
the source will be lost.</li>
<li>Broadly, Literals, Trivia, which is things like keywords, commas,
semicolons, brackets of all kinds</li>
<li>And of course Spacing.</li>
<li>Let look at each of these in turn</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgcd50f9b">
<h3 id="orgcd50f9b">Literals</h3>
<div class="org-src-container">

<pre class="fragment appear"><code class="haskell" >1, 0x01, 001, 0_01
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment appear"><code class="haskell" >{-# Language CPP #-}
{-# LANGUAGE CPP #-}
</code></pre>
</div>

<aside class="notes">
<ul>
<li>Take parsing a simple integer constant, value 1.
&lt;NEXT&gt;
<ul>
<li>These are all ways it can be written.</li>

</ul></li>
<li>Or a pragma. &lt;NEXT&gt;</li>
<li>So we have to keep the as-written text for all of these.</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgb9b4f23">
<h3 id="orgb9b4f23">Trivia</h3>
<div class="org-src-container">

<pre><code class="haskell" >let
   fa :: Int
   fa = 1
in fa
</code></pre>
</div>

<aside class="notes">
<ul>
<li>Here is a fragment of code for a let expression.</li>
<li>Trivia is `let`, `::`, `=`, `in`</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org2f3df74">
<h3 id="org2f3df74">Spacing</h3>
<aside class="notes">
<ul>
<li>Spacing is a funny thing.</li>
<li>To simply reproduce the original code, we use the SrcSpan locations,
no problem.</li>
<li><p>
But when you want to change things it gets complicated
</p>
<ul>
<li>Add or delete lines</li>
<li>Move a block of code from one place to another
<ul>
<li>Which can also change its indentation</li>

</ul></li>

</ul>
<p>
&lt;NEXT&gt;
</p></li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org52f6267">
<h3 id="org52f6267">Principle for Spacing</h3>
<p>
A located AST element is treated as a self-contained unit
</p>
<ul>
<li class="fragment appear">Looking in
<ul>
<li>Everything we need to print it is inside</li>
<li>Nothing is printed outside its span</li>

</ul></li>
<li class="fragment appear">Looking out
<ul>
<li>We believe its span start point</li>
<li>We believe its span end point</li>

</ul></li>

</ul>

<aside class="notes">
<ul>
<li>The exact print annotations embody a principle for spacing</li>
<li>We apply this principle to be able to change and print
(meaningfully) an ast.
&lt;NEXT&gt;</li>
<li>when we are inside the fragment, we have everything we need to be
able to print it.</li>
<li>we can print it based only on what is inside
&lt;NEXT&gt;</li>
<li>Looking out belief: we will clarify what this means in subsequent slides</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgdd791ba">
<h3 id="orgdd791ba">Spacing : printing</h3>
<ul>
<li>A self-contained AST element has absolute locations</li>
<li>When we print, we have a print head that we advance</li>
<li>By distances calculated from the absolute locations</li>

</ul>
<aside class="notes">
<p>
So
</p>
<ul>
<li>We track two locations
<ul>
<li>The output print position, which always advances as we print</li>
<li>The offset calculation position, which we reset every time we enter a span
<ul>
<li>(remember “we believe the start position of a span”)</li>

</ul></li>
<li>And also set every time we exit a span (“belief”)</li>
<li>Otherwise it also advances as we print</li>

</ul></li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org655d538">
<h3 id="org655d538">Spacing example</h3>

<div id="org61a9f9d" class="figure">
<p><img src="./images-work/let-in-boxes-raw.png" alt="let-in-boxes-raw.png" />
</p>
</div>
<aside class="notes">
<p>
Here is our let expression again
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org26a8420">
<h3 id="org26a8420">Spacing example: top box</h3>

<div id="org56cfceb" class="figure">
<p><img src="./images-work/let-in-boxes-top.png" alt="let-in-boxes-top.png" />
</p>
</div>

<aside class="notes">
<p>
At the top level, it is wrapped in a SrcSpan, setting its start and end position
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org42e359a">
<h3 id="org42e359a">Spacing example: interior boxes</h3>

<div id="orgaed3a8b" class="figure">
<p><img src="./images-work/let-in-boxes-middle.png" alt="let-in-boxes-middle.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>If we go into the box, we find 4 more</li>
<li>Two are trivia, two are more boxes we can go into</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org21e8c67">
<h3 id="org21e8c67">Spacing example: spacing</h3>

<div id="orgc0494ea" class="figure">
<p><img src="./images-work/let-in-boxes-spacing.png" alt="let-in-boxes-spacing.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>We use distance from the end of one span to the start of the next to</li>

</ul>
<p>
work out how much space to emit when printing
</p>
<ul>
<li>And we believe the start and end span locations for these
calculations.</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orga9755a6">
<h3 id="orga9755a6">Spacing : the missing piece</h3>
<ul>
<li class="fragment appear">How do we change things?</li>
<li class="fragment appear"><p>
Deltas : Directly provide the spacing
</p>

<aside class="notes">
<p>
There is one remaining problem
&lt;NEXT&gt;
</p>
<ul>
<li><p>
How do we change things?
</p>
<ul>
<li>If we delete a piece, there will be a gap</li>
<li>If we add something, there will be some kind of jump</li>

</ul>
<p>
&lt;NEXT&gt;
</p></li>
<li>Deltas
<ul>
<li>At the point where we change from one self contained point
to a changed one, we supply the delta directly</li>
<li>Instead of calculating it from the offset calculation position.</li>
<li>And then set the offset calculation position according to the next
actual span we see</li>
<li>We believe the start position in a span</li>
<li>It will come after a delta, so the spacing is known</li>

</ul></li>

</ul>

</aside></li>

</ul>

</section>
</section>
<section>
<section id="slide-org6f2ef77">
<h3 id="org6f2ef77">Spacing size changes example</h3>

<div id="orgf925541" class="figure">
<p><img src="./images-work/let-in-longer-boxes-raw.png" alt="let-in-longer-boxes-raw.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>Say we want to rename `fa` to `falonger`, and just update the
literal text in the AST
<ul>
<li>(for each appropriate `HsVar`)</li>

</ul></li>
<li>But we make no other changes</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org759445e">
<h3 id="org759445e">Spacing size changes example: spacing</h3>

<div id="orgf32ccb9" class="figure">
<p><img src="./images-work/let-in-longer-boxes-spacing.png" alt="let-in-longer-boxes-spacing.png" />
</p>
</div>
<aside class="notes">
<ul>
<li>It's hard to draw this, but imagine the blue boxes are the same ones
from before, not changed for the longer insides</li>
<li>The spacing calculation to the start point is unchanged, so all is
good</li>
<li>When we finish, we set the offset calculation position to the end of the span
(We believe the end position)</li>
<li>And so following spacing calculations are unaffected.</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orga650135">
<h3 id="orga650135">Spacing : size changes 2</h3>
<ul>
<li>The same principle holds for bigger changes.</li>
<li>If we add additional content inside a span, it does not matter,</li>
<li>The “contract” with the surroundings is the start of the span for
entry spacing</li>
<li>And the end of the span for exit spacing</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd8e692d">
<h3 id="orgd8e692d">Spacing : deltas</h3>
<div class="org-src-container">

<pre><code class="haskell" data-line-numbers>data DeltaPos
  = SameLine { deltaColumn :: Int }
  | DifferentLine { deltaLine :: Int, deltaColumn :: Int }
</code></pre>
</div>

<aside class="notes">
<ul>
<li>The red arrows above map onto a `DeltaPos`, which can have line/col</li>
<li>Haskell is a layout-sensitive language</li>
<li>Our offset position also tracks the current indentation level, so
the <code>deltaColumn</code> is added to that.</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgaad5673">
<h3 id="orgaad5673">Ordering things</h3>
<ul>
<li><code>ParsedSource</code> is not a completely accurate reflection of the original source.</li>
<li><code>ValBinds</code> separates out <code>[Sig]</code>  and <code>[Bind]</code></li>
<li><code>ClassDecl</code> and  <code>ClsInstDecl</code> separate out <code>Bind</code> s,
<code>Sig</code> s, Type family instances etc</li>
<li>For all of these, the original source can have them in any order.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd5e609a">
<h3 id="orgd5e609a">Ordering things 2</h3>
<ul>
<li>For an unmodified AST there is no problem, you just sort by start of
span.</li>
<li>But a modified one may have rearranged the existing ones, or brought
in ones from elsewhere.</li>
<li>And may have adjusted the spacing with explicit deltas.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org0c48d81">
<h3 id="org0c48d81">Order in lists 3</h3>

<div id="org9ce7e9f" class="figure">
<p><img src="./images-work/ordering-smaller.png" alt="ordering-smaller.png" />
</p>
</div>

<div id="orgcba3ca2" class="figure">
<p><img src="./images-work/ordering-sortkey-smaller.png" alt="ordering-sortkey-smaller.png" class="fragment" />
</p>
</div>

<aside class="notes">
<p>
so we draw first from the signatures, then the binds, and same again.
</p>
<ul>
<li>Each specific list is physically ordered, so for <code>ValBinds</code> we know
the order of the sigs, and of the binds.</li>
<li>But we don’t know the interleaving.</li>
<li>We supply this in an <code>AnnSortKey</code>, which drives a merge process.</li>
<li>It keeps a list of <code>SigDTag</code> or <code>BindTag</code> for
a <code>ValBind</code>, telling which list to draw from each time.</li>

</ul>

</aside>


</section>
</section>
<section>
<section id="slide-org15f8dfa">
<h3 id="org15f8dfa">Comments</h3>
<ul>
<li>Comments are the ultimate “trivia”. They have no influence on
overall spacing and layout, but need to be preserved precisely.</li>
<li>They can also occur absolutely anywhere in the source file.</li>
<li>So we keep them in the "<code>SrcSpan</code> on steroids" we wrap
everything in, and fit them in when we print, if they fit into the
current gap.</li>
<li>It’s more complicated than that, but we will look into detail later.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgbc2f576">
<h3 id="orgbc2f576">Trailing Items</h3>

<div id="org450ef26" class="figure">
<p><img src="./images-work/do-trailing-boxes.png" alt="do-trailing-boxes.png" />
</p>
</div>

<aside class="notes">
<ul>
<li>The ast can be seen as an assembly of nested, ordered, self-contained boxes.</li>
<li>To keep them reusable, we leave trailing items in the upper level.</li>
<li>The self-contained belief we base everything on is that everything fits
inside the AST Element span.</li>
<li>This is true for everything, except trailing items.</li>
<li>If you consider a list of items, each item is a standalone entity</li>
<li>The commas exist as part of the surrounding structure.</li>
<li>So if you move the item elsewhere, or replace it with something
else, the trailing comma should be managed as part of that location.</li>
<li>Others are semicolons, vertical bars, single and double arrows</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgc14830c">
<h3 id="orgc14830c">End of Hand Wavy Part</h3>
<ul>
<li>Hopefully you now have a high level understanding of what the exact
print annotations are for</li>
<li>Now we can look into some details of how things are captured in GHC</li>

</ul>


</section>
</section>
<section>
<section id="slide-org833a010">
<h2 id="org833a010">What it means inside GHC</h2>
<ul>
<li>Located things</li>
<li>Internal Annotations</li>

</ul>

<aside class="notes">
<p>
Time to dive into the detail. Two main divisions
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org621be0a">
<h3 id="org621be0a">Terminology</h3>
<ul>
<li>AST means <code>ParsedSource</code></li>

</ul>

<div class="org-src-container">

<pre><code class="haskell" >type ParsedSource = Located (HsModule GhcPs)
</code></pre>
</div>

<p>
For now we accept <code>GhcPs</code> as simply a marker of the AST from the
parsing phase.
</p>

</section>
</section>
<section>
<section id="slide-orgc650af1">
<h3 id="orgc650af1">Located Things</h3>
<aside class="notes">
<ul>
<li>The AST is layered, as we saw in the boxes diagrams earlier.</li>
<li>The types around location are a bit complex, being driven mainly by
type families.</li>
<li>My mental model is they are functions from a type to a type.</li>
<li>Lets start with the first one
&lt;NEXT&gt;</li>

</ul>

</aside>

</section>
<section id="slide-orgf505868">
<h4 id="orgf505868">Location</h4>
<div class="org-src-container">

<pre><code class="haskell" >type family XRec p a = r | r -&gt; a
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="haskell" >type family Anno a = b
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="haskell" >type instance XRec (GhcPass p) a = GenLocated (Anno a) a
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="haskell" >type LHsExpr p = XRec p (HsExpr p)
type instance Anno (HsExpr (GhcPass p)) = SrcSpanAnnA
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="haskell" >type SrcSpanAnnA = EpAnn AnnListItem
</code></pre>
</div>

<aside class="notes">
<ul>
<li>XRec has a parameter p, and maps a type 'a' to a type 'r', and fundeps say the reverse holds too.</li>
<li>`p` is a parameter that is chased through the entire AST, and for `ParsedSource` is always `GhcPs`
&lt;NEXT&gt;</li>
<li>Anno is a type function from `a` to `b`
&lt;NEXT&gt;</li>
<li>We create an instance (= mapping) of XRec for all GhcPass types as being located by Anno a</li>
<li>Lets make this concrete
&lt;NEXT&gt;</li>
<li>LHsExpr is defined as an XRec type</li>
<li>And it's Anno instance is SrcSpanAnnA
&lt;NEXT&gt;</li>
<li>which in turn is this EpAnn AnnListItem</li>

</ul>

</aside>

</section>
<section id="slide-orgcf6561e">
<h4 id="orgcf6561e">EpAnn</h4>
<div class="org-src-container">

<pre><code class="haskell" >data EpAnn ann = EpAnn
         { entry    :: !Anchor -- basically SrcSpan when parsed
         , anns     :: !ann
         , comments :: !EpAnnComments
         }
type Anchor = EpaLocation
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="haskell" >type EpaLocation = EpaLocation' [LEpaComment]
data EpaLocation' a = EpaSpan !SrcSpan
                    | EpaDelta !DeltaPos !a
</code></pre>
</div>

<aside class="notes">
<ul>
<li>EpAnn is an augmented SrcSpan</li>
<li>the `entry` field is basically a SrcSpan when parsed</li>
<li>`ann` is the parameterised type, `AnnListItem` in our example</li>
<li>`comments` captures any comments included in the immediate
descendents of the thing being located by this. between the sub
boxes in the first section.
&lt;NEXT&gt;</li>
<li>As I said, the as-parsed EpaLocation is EpaSpan, holding a SrcSpan</li>
<li>EpaDelta is used for editing and reprinting, we will deal with it in
the next section.</li>
<li>You will notice a delta also has comments. This is because we can't
sort anything, with deltas, so for trivia having preceding comments
we put them here.</li>

</ul>

</aside>

</section>
<section id="slide-orge0d6be2">
<h4 id="orge0d6be2"><code>AnnListItem</code></h4>
<div class="org-src-container">

<pre><code class="haskell" >-- | Annotation for items appearing in a list. They can have one or
-- more trailing punctuations items, such as commas or semicolons.
data AnnListItem
  = AnnListItem {
      lann_trailing  :: [TrailingAnn]
      }
</code></pre>
</div>

<aside class="notes">
<ul>
<li>A trailingann is an enumeration of a kind of trailing item and its EpaLocation
<ul>
<li>So semicolon, comma, arrow, darrow, and vertical bar</li>

</ul></li>
<li>we saw them in the previous section, a semicolon</li>

</ul>

</aside>

</section>
<section id="slide-orgd406e9e">
<h4 id="orgd406e9e">Sanity check</h4>
<p>
Tie up to prior hand wavy part
</p>
<pre class="example" id="org7011f27">
(L
 (EpAnn
  (EpaSpan { DumpParsedAst.hs:5:1-16 })
  (AnnListItem
   [])
  (EpaComments
   []))
   ...
</pre>


<aside class="notes">
<ul>
<li>After this deep dive into types, let's come up for air a bit.</li>
<li>If you recall in the handwavy part we spoke about span being the
source of truth, the thing we believe.</li>
<li><code>SrcSpan</code> we "believe" is the one in the <code>EpAnn</code> <code>entry</code>, using the
<code>EpaSpan</code> constructor.</li>
<li>If we need to move things around, the surgery happens by replacing
it with an appropriate <code>EpaDelta</code> version, just for the
point where the change happens.</li>
<li>For ghc-exactprint old hands, makeDeltaAst is no longer required (but still exists)</li>
<li>Now back to the next kind, storage of internal annotations</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgd5a9d1a">
<h3 id="orgd5a9d1a">Internal Annotations</h3>
<ul>
<li><code>SourceText</code> for Literals,</li>
<li>keywords (via <code>AnnKeywordId</code> or <code>EpToken</code>)</li>

</ul>

<aside class="notes">
<ul>
<li>everything that is not a location, comment, or surrounding
 information, but is needed for exact printing.
SourceText keeps the as-written source text of a literal, so it can be used when printing.</li>
<li>keywords or trivia are all the other punctuation marks.
<ul>
<li>When not in a trailing usage.</li>

</ul></li>

</ul>

</aside>

</section>
<section id="slide-org234abb9">
<h4 id="org234abb9"><code>AnnKeywordId</code></h4>
<div class="org-src-container">

<pre><code class="haskell" >data AnnKeywordId
    ...
    | AnnIn
    | AnnLet
data AddEpAnn = AddEpAnn AnnKeywordId EpaLocation
</code></pre>
</div>

<aside class="notes">
<ul>
<li>This is the original mechanism for capturing trivia.</li>
<li>It is an enumeration of what it is, together with its location.</li>

</ul>

</aside>

</section>
<section id="slide-orgae461b6">
<h4 id="orgae461b6"><code>EpToken</code></h4>
<div class="org-src-container">

<pre><code class="haskell" >data EpToken (tok :: Symbol)
  = NoEpTok
  | EpTok !EpaLocation
</code></pre>
</div>

<p>
Used as a type <code>EpTok "let"</code>
</p>

<div class="org-src-container">

<pre class="fragment"><code class="haskell" >-- Extract string for printing
getEpTokenString :: forall tok. KnownSymbol tok =&gt; EpToken tok -&gt; Maybe String
getEpTokenString NoEpTok = Nothing
getEpTokenString (EpTok _) = Just $ symbolVal (Proxy @tok)
</code></pre>
</div>

<aside class="notes">
<ul>
<li>This is the new mechanism. May eventually supplant AddEpAnn and AnnKeywordId</li>
<li>Apart from <code>NoEpTok</code>, this is isomorphic to <code>AddEpAnn</code>
&lt;NEXT&gt;</li>
<li>And this shows you how to get the "let" back out for the example</li>

</ul>

</aside>

</section>
<section id="slide-orgbc07e48">
<h4 id="orgbc07e48">Internal Annotation storage</h4>
<aside class="notes">
<p>
Back into type function land, as we look into how these keywords are
stored in an AST element.
</p>

</aside>

</section>
<section id="slide-org86da452">
<h4 id="org86da452">Trees That Grow</h4>
<ul>
<li>GHC AST implements “Trees That Grow”</li>
<li>This means extra information can be carried, computed via type classes</li>
<li>We call them "Extension points"</li>

</ul>

</section>
<section id="slide-org8f393f0">
<h4 id="org8f393f0">Refresher</h4>
<div class="org-src-container">

<pre><code class="haskell" >data HsExpr p
  ...
  | HsLet (XLet p) (HsLocalBinds p) (LHsExpr  p)

type family XLet x
</code></pre>
</div>
<div class="org-src-container">

<pre class="fragment"><code class="haskell" >type instance XLet GhcPs = (EpToken "let", EpToken "in")
</code></pre>
</div>

<div id="orga9ac3c7" class="figure">
<p><img src="./images-work/let-in-boxes-middle-smaller.png" alt="let-in-boxes-middle-smaller.png" class="fragment" />
</p>
</div>
<aside class="notes">
<ul>
<li>Every constructor in the GHC AST has a first field named something
like XLet for HsLet constructor</li>
<li>It is parameterised by the global AST parameter p</li>
<li>And there is a type family for it, so instances can be defined to
map it onto a concrete type.
&lt;NEXT&gt;</li>
<li>For XLet and GhcPs this is a tuple for a let and an in token
&lt;NEXT&gt;</li>
<li>Going back to our example, these capture the locations in violet</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgd009910">
<h3 id="orgd009910">Recap</h3>
<aside class="notes">
<p>
This section has scratched the surface. There is a lot more I have not covered, e.g.
</p>
<ul>
<li><code>LocatedN RdrName</code></li>
<li>Annotations around lists, context, pragmas and so on</li>
<li>But we will now look at how we use it for its intended purpose,
tools to change and emit updated source.</li>
<li>Recall my original motivation was the haskell refactorer</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgdf06920">
<h2 id="orgdf06920">What it means outside GHC</h2>
<ul>
<li>The Exact Print Annotations are packaged for use in <a href="https://hackage.haskell.org/package/ghc-exactprint">ghc-exactprint</a></li>
<li>Generally a "hidden" library, enabling others
<ul>
<li>hlint apply hints</li>
<li>various plugins in HLS</li>
<li>built for HaRe, but that now languishes</li>
<li>retrie</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgfb4217b">
<h3 id="orgfb4217b">ghc-exactprint big picture</h3>
<ul>
<li>Parse</li>
<li>Transform</li>
<li>Print</li>

</ul>

<aside class="notes">
<ul>
<li>The usual thing. input, process, output.</li>
<li>Lets look at each in turn</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgfa12b6c">
<h3 id="orgfa12b6c">ghc-exactprint parsing</h3>
<div class="org-src-container">

<pre><code class="haskell" >type Parser a = GHC.DynFlags -&gt; FilePath -&gt; String -&gt; ParseResult a
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="haskell" >parseExpr :: Parser (GHC.LHsExpr GHC.GhcPs)
parseImport :: Parser (GHC.LImportDecl GHC.GhcPs)
parseType :: Parser (GHC.LHsType GHC.GhcPs)
parseDecl :: Parser (GHC.LHsDecl GHC.GhcPs)
parseStmt :: Parser (GHC.ExprLStmt GHC.GhcPs)
parsePattern :: Parser (GHC.LPat GHC.GhcPs)
</code></pre>
</div>

<aside class="notes">
<ul>
<li><p>
a pure function
</p>
<ul>
<li>FilePath is used just for SrcSpan construction</li>
<li>String is the source</li>

</ul>
<p>
&lt;NEXT&gt;
</p></li>
<li>We have ones for various subcomponents</li>
<li>They are an option for constructing fragments to be inserted into an
existing AST somewhere</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org01f70e3">
<h3 id="org01f70e3">ghc-exactprint parseModule</h3>
<div class="org-src-container">

<pre><code class="haskell" >parseModule :: LibDir -&gt; FilePath -&gt; IO (ParseResult GHC.ParsedSource)
</code></pre>
</div>

<aside class="notes">
<ul>
<li>This is the main one used when actually changing a module</li>
<li>"best effort" with CPP
<ul>
<li>compares original with preprocessed, and turns the diff into
comments</li>
<li>cannot work if <code>#define XX Blah</code> and then <code>XX</code> is used. <code>XX</code> added as a comment, as well as <code>Blah</code></li>

</ul></li>
<li>Honours pragmas, but you need to set <code>DynFlags</code> for any e.g. project-wide options</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgd851745">
<h3 id="orgd851745">ghc-exactprint transform</h3>
<ul>
<li>The reason <code>ghc-exactprint</code> exists</li>

</ul>
<aside class="notes">
<ul>
<li>And the exact print annotations in GHC</li>
<li>Intention: smallest changes possible</li>
<li>So makeDeltaAst is no longer needed, and makes it impossible to map
locations back to the AST to be changed.</li>
<li>But lets first go off at a tangent</li>

</ul>

</aside>

</section>
<section id="slide-orgca4c856">
<h4 id="orgca4c856">Comments</h4>
<p>
Stored in <code>EpAnn</code>
</p>

<div class="org-src-container">

<pre><code class="haskell" >data EpAnnComments = EpaComments
                        { priorComments :: ![LEpaComment] }
                   | EpaCommentsBalanced
                        { priorComments     :: ![LEpaComment]
                        , followingComments :: ![LEpaComment] }
</code></pre>
</div>

<aside class="notes">
<ul>
<li>The initial parsing is optimised for speed, you are not necessarily
going to change things</li>
<li>Once you decide to move thing around, you need to decide which
comments to bring along.</li>
<li>The comments constructors initially carry priorComments only, which
precede the given declarations.</li>

</ul>

</aside>

</section>
<section id="slide-org7dedf15">
<h4 id="org7dedf15"><code>balanceComments</code></h4>
<div class="org-src-container">

<pre><code class="haskell" >-- a random comment


-- here is a function
foo = 3
-- here is a trailing comment

-- Another random aside

-- another function
bar = 2
</code></pre>
</div>

<aside class="notes">
<ul>
<li><code>ghc-exactprint</code> has <code>balanceComments</code> and <code>balanceCommentsList</code></li>
<li>These use heuristics to "attach" comments to the appropriate
declaration in a list</li>
<li>Here is some example source.  When we balance comments</li>

</ul>

</aside>

</section>
<section id="slide-org516c865">
<h4 id="org516c865">becomes</h4>
<div class="org-src-container">

<pre><code class="haskell" >-- a random comment
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="haskell" >-- here is a function
foo = 3
-- here is a trailing comment
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="haskell" >-- Another random aside

-- another function
bar = 2
</code></pre>
</div>

<aside class="notes">
<ul>
<li>The first comment is attached to the module header. Or to the first
declaration if it is a lower level list</li>
<li>The next two become prior and following comments for foo.</li>
<li>following comments are kept if they immediately follow a declaration.</li>
<li>And the last two become prior comments for bar.</li>
<li>This makes a given list of declarations ready for modification.
<ul>
<li>You can take one and move it somewhere else, or insert a new one
in between, and hopefully the comments will still make sense.</li>

</ul></li>

</ul>

</aside>

</section>
<section id="slide-org99c6cbd">
<h4 id="org99c6cbd"><code>FunBind</code> comments</h4>
<div class="org-src-container">

<pre><code class="haskell" >-- a random comment


-- here is a function
foo True = 3
-- here is a trailing comment

-- Another random aside

-- another function
foo False = 2
-- trailing second fun
</code></pre>
</div>

<aside class="notes">
<ul>
<li><code>FunBind</code> is weird</li>
<li>it combines all the equations for a particular function</li>
<li>each shows up as a <code>Match</code>, which is self-contained</li>

</ul>

</aside>

</section>
<section id="slide-org8886bd4">
<h4 id="org8886bd4">becomes</h4>
<div class="org-src-container">

<pre><code class="haskell" >-- a random comment
</code></pre>
</div>

<p>
On FunBind prior comments
</p>
<div class="org-src-container">

<pre><code class="haskell" >-- here is a function
</code></pre>
</div>

<p>
First match (OOPS, BUG in 1.10.0.0)
</p>
<div class="org-src-container">

<pre><code class="haskell" >foo True = 3
</code></pre>
</div>

<p>
Second match
</p>
<div class="org-src-container">

<pre><code class="haskell" >-- here is a trailing comment

-- Another random aside

-- another function
foo False = 2
</code></pre>
</div>

<p>
On FunBind following comments
</p>
<div class="org-src-container">

<pre><code class="haskell" >-- trailing second fun
</code></pre>
</div>

</section>
<section id="slide-org85433fe">
<h4 id="org85433fe">Produced by</h4>
<div class="org-src-container">

<pre><code class="haskell" >test = TestList [mkTestModChange libdir balanceComments "AFile.hs"]

balanceComments :: Changer
balanceComments _libdir lp = return $ replaceDecls lp ds'
  where
    ds = hsDecls lp
    ds' = balanceCommentsList ds
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org72c2562">
<h3 id="org72c2562"><code>class HasDecls</code></h3>
<div class="org-src-container">

<pre><code class="haskell" >class (Data t) =&gt; HasDecls t where
    hsDecls :: t -&gt; [LHsDecl GhcPs]
    replaceDecls :: t -&gt; [LHsDecl GhcPs] -&gt; t
</code></pre>
</div>

<aside class="notes">
<ul>
<li><p>
hasDecls
</p>
<ul>
<li>Return the 'HsDecl's that are directly enclosed in the</li>

</ul>
<p>
given syntax phrase. They are always returned in the wrapped
'HsDecl' form, even if orginating in local decls. This is safe,
as annotations never attach to the wrapper, only to the wrapped
item.
</p></li>
<li><p>
replaceDecls
</p>
<ul>
<li></li>

</ul>
<p>
Replace the directly enclosed decl list by the given
decl list. As parto of replacing it will update list order
annotations, and rebalance comments and other layout changes as needed.
</p></li>

</ul>
<p>
&#x2013;
For example, a call on replaceDecls for a wrapped 'FunBind' having no
where clause will convert
&#x2013;
@
&#x2013; |This is a function
foo = x &#x2013; comment1
&#x2013;
in to
&#x2013;
&#x2013; |This is a function
foo = x &#x2013; comment1
  where
    nn = 2
</p>

</aside>

</section>
<section id="slide-orge0d3328">
<h4 id="orge0d3328"><code>replaceDecls</code></h4>
<div class="org-src-container">

<pre><code class="haskell" >-- |This is a function
foo = x -- comment1
-- trailing comment
</code></pre>
</div>

<p>
to
</p>

<div class="org-src-container">

<pre><code class="haskell" >-- |This is a function
foo = x -- comment1
  where
    nn = 2
-- trailing comment
</code></pre>
</div>

</section>
<section id="slide-org44654e4">
<h4 id="org44654e4">code for the replace</h4>
<div class="org-src-container">

<pre><code class="haskell" >addLocaLDecl1 :: Changer
addLocaLDecl1 libdir top = do
  Right (L ld (ValD _ decl)) &lt;- withDynFlags libdir (\df -&gt; parseDecl df "decl" "nn = 2")
  let
      decl' = setEntryDP (L ld decl) (DifferentLine 1 5)
      (de1:d2:d3:_) = hsDecls top
      (de1',d2') = balanceComments de1 d2
      (de1'',_) = modifyValD (getLocA de1') de1' $ \_m d -&gt;
                   ((wrapDecl decl' : d), Nothing)
  return $ replaceDecls top [de1'', d2', d3]
</code></pre>
</div>

</section>
<section id="slide-org79e1101">
<h4 id="org79e1101"><code>modifyValD</code></h4>
<ul>
<li>Remember <code>FunBind</code>?</li>

</ul>

<div class="org-src-container">

<pre><code class="haskell" >..
[ma1,_ma2] = ms -- of de1
(de1',_) = modifyValD (getLocA ma1) de1 $ \_m decls -&gt;
             (newDecl : decls, Nothing)
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="haskell" >type Decl  = LHsDecl GhcPs
type PMatch = LMatch GhcPs (LHsExpr GhcPs)
modifyValD
   :: forall t. SrcSpan -&gt; Decl
   -&gt; (PMatch -&gt; [Decl] -&gt; ([Decl], Maybe t))
   -&gt; (Decl, Maybe t)
</code></pre>
</div>


<aside class="notes">
<p>
&#x2013; |Modify a 'LHsBind' wrapped in a 'ValD'. For a 'PatBind' the
&#x2013; declarations are extracted and returned after modification. For a
&#x2013; 'FunBind' the supplied 'SrcSpan' is used to identify the specific
&#x2013; 'Match' to be transformed, for when there are multiple of them.
</p>

<p>
Note: now that everything is pure, and connected, pretty much not
needed.
</p>

</aside>

</section>
<section id="slide-orgbf84ea4">
<h4 id="orgbf84ea4">packFunBind, unpackFunBind</h4>
<p>
And packFunDecl, unpackFunDecl
</p>

</section>
<section id="slide-orgc9d0d6c">
<h4 id="orgc9d0d6c">addToList etc</h4>

</section>
<section id="slide-orga230879">
<h4 id="orga230879">replaceDecls sort order</h4>
<ul>
<li>Remember <code>AnnSortKey</code>?</li>
<li>It is populated in <code>replaceDecls</code></li>
<li><code>captureOrderBinds</code></li>
<li><code>replaceDeclsClassDecl</code> (and <code>hsDeclsClassDecl</code>)</li>

<li><p>
<code>oderedDecls</code>
When <code>NoAnnSortKey</code>,
</p>
<ul>
<li>Assume working with an unchanged AST</li>
<li>use the locations of the decls and sort</li>

</ul>
<p>
When <code>AnnSortKey DeclTag</code>
</p>
<ul>
<li>Build <code>Map.Map DeclTag [LHsDecl GhcPs]</code> from assorted <code>ClassDecl</code> parts</li>
<li></li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgfc88c6a">
<h3 id="orgfc88c6a">Summary</h3>
<ul>
<li>balance comments</li>
<li>manage funbind comment details</li>
<li>manage <code>where</code> for adding/removing decls to <code>HsValBinds</code></li>
<li>track sort order</li>
<li>wrap/unwrap binds</li>

</ul>

</section>
</section>
<section>
<section id="slide-org0fa3363">
<h3 id="org0fa3363">ghc-exactprint print</h3>
<p>
This is the heart of the thing
</p>

<p>
But will not look in detail, it is too complex
</p>

<p>
Suffice to say,
</p>

<div class="org-src-container">

<pre><code class="haskell" >exactPrint :: ExactPrint ast =&gt; ast -&gt; String
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgeb634f4">
<h3 id="orgeb634f4">Name tie-ups</h3>
<ul>
<li>All <code>RdrName</code> s in the AST are <code>LocatedN</code>, containing
a <code>SrcSpan</code> when originally parsed.</li>
<li>The <code>RenamedSource</code> does not remove named locations,
although it may move them around a bit.</li>
<li><p>
So perform a generic traversal of the <code>RenamedSource</code>,
building a map of
</p>
<div class="org-src-container">

<pre><code class="haskell" >SrcSpan -&gt; Name
</code></pre>
</div></li>

</ul>


</section>
</section>
<section>
<section id="slide-orgb602640">
<h2 id="orgb602640">Future</h2>
<ul>
<li>Fixity info</li>
<li><code>GHC_CPP</code></li>
<li>Free vars?</li>
<li>Easy Export of Name table for lookup?</li>
<li>ghc-exactprint API
<ul>
<li>currently provisional</li>
<li><p>
should it be split?
</p>
<ul>
<li>parsing</li>
<li>printing</li>
<li>low-level API</li>

</ul>
<p>
rest outside
</p></li>
<li>where should it live?</li>

</ul></li>
<li>Link-up with ghc-lib-parser</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgc385a7f">
<h2 id="orgc385a7f">GHC 9.10</h2>
<ul>
<li>Sorry for the breakage</li>
<li>Porting/changes at <a href="https://gist.github.com/alanz/e127e7561ddf1cfeb07fbdee9a966794">Exact Print Annotations GHC 9.10 changes</a></li>
<li>TLDR
<ul>
<li>remove <code>makeDeltaAst</code>, otherwise there will be no <code>SrcSpan</code>
anywhere in the AST (but when ready to make a change, using it to
capture spacing of the local thing being edited may help)</li>
<li><code>EpAnnNotUsed</code> is gone, use <code>noAnn</code> instead</li>
<li><code>uniqueSrcSpanT</code> is no longer needed, use an appropriate
<code>EpaDelta</code> location instead</li>
<li><code>EpaDelta (DifferentLine row col)</code> interprets <code>col</code> differently.
You must add 1 to get the prior spacing.</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org06b5ec0">
<h2 id="org06b5ec0">End</h2>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>
<script src="./reveal.js/plugin/highlight/highlight.js"></script>
<script src="./reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: false,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'linear',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealHighlight, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
