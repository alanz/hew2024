#+Title: ghc-exactprint (HEW 2024)
#+Author: Alan Zimmerman
#+Email: @alanz@social.coop

#+REVEAL_TITLE_SLIDE:
# #+REVEAL_SLIDE_FOOTER: Haskell Ecosystem Workshop, ZuriHac 2024

#+REVEAL_INIT_OPTIONS: width:1200, height:800, margin: 0.1, minScale:0.2, maxScale:2.5
#+OPTIONS: num:nil
#+OPTIONS: reveal_slide_number:c/t
#+OPTIONS: toc:1
#+OPTIONS: reveal_center:nil
# #+REVEAL_THEME: simple
# #+REVEAL_THEME: white-contrast
#+REVEAL_THEME: white_contrast_compact_verbatim_headers
#+REVEAL_HLEVEL: 2
#+REVEAL_TRANS: linear
# #+REVEAL_PLUGINS: (markdown notes )
# #+REVEAL_PLUGINS: (markdown notes highlight toc-pogress)
#+REVEAL_PLUGINS: (markdown notes highlight)
#+REVEAL_EXTRA_CSS: ./local.css
#+REVEAL_EXTRA_CSS: ./reveal.js/plugin/toc-progress/toc-progress.css
#+REVEAL_HIGHLIGHT_CSS: %r/plugin/highlight/github.css
#+PROPERTY: header-args    :results silent
#+PROPERTY: header-args    :exports code


#+ATTR_REVEAL: :reveal_slide_global_footer 'footer hello'

# ####################################################
# For TOC-progress, need in Reveal.initialize({
#
# // Optional libraries used to extend reveal.js
# dependencies: [
#     ..
#     { src: './reveal.js/plugin/toc-progress/toc-progress.js'
#       , async: true
#       , callback: function() { toc_progress.initialize(); toc_progress.create(); }
#     }
# ]
# });
# ####################################################

* ghc-exactprint

Alan Zimmerman

[[https://social.coop/@alanz][~@alanz@social.coop~]]

Haskell Ecosystem Workshop,
ZuriHac, 2024-06-07

* About Me
- Learned Haskell in 2012
- Decided to resurrect HaRe, using GHC backend
- First GHC commit Sep 2014
- Led to haskell-ide-engine, to expose it to users
- And into GHC to make it useful for this

* This Talk
- Overview of the problem being solved
- What it means inside GHC
- What it means outside GHC

  #+begin_notes
  - Going through material, it is a huge topic, chat to me at ZuriHac
  - First a Hand-wavy attempt to motivate the problem being solved
  - Then how we capture the required information inside GHC, aimed at
    GHC developers and ghc-exactprint users
  - Finally how to use the provided facilities in the real world
  #+end_notes

* Problem Being Solved
To allow a tool to
- start from a ~GHC~ ~ParsedSource~,
- make changes to it,
- print source reflecting the changes.
- And only the changes.

** Start from GHC ParsedSource
- It must accurately reflect the input source
- Literals
- ‘Trivia’
  Things like keywords, commas, semicolons, brackets of all kinds
- Spacing

** Literals Detail
TBD
(AZ note, see LiteralsTest.hs in testsuite, and HIW2021 slide)

** Capturing Trivia
TBD. Possibly skip this slide

** Spacing
- Spacing is a funny thing.
- To start with, it is just a given. This is where things are in the
  source, all wrapped in a SrcSpan
- But when you want to change things it gets complicated
  - Add or delete lines
  - Move a block of code from one place to another
    - Which can also change its indentation

** Principles for Spacing
- A located AST element is treated as a unit
  - We believe its span start point
  - We believe its span end point
  - Nothing is printed outside its span
- It is self-contained
  - If we apply a constant (line,col) offset to the whole thing, it
    will still print properly
- Implication
  - If we do some book-keeping about the start offset, we can print it
    anywhere
#+begin_notes
What happens in the box, stays in the box
#+end_notes
** Spacing : the trick
- A self-contained AST element has absolute locations
- When we print, we have a print head that we advance
- By distances calculated from the absolute locations
So
- We track two locations
  - The output print position, which always advances as we print
  - The offset calculation position, which we reset every time we enter a span
    - (remember “we believe the start position of a span”)
  - And also set every time we exit a span (“belief”)
  - Otherwise it also advances as we print

** Spacing : the missing piece
There is one remaining problem
- How do we change things?
  - If we delete, there will be a gap
  - If we add something, there will be some kind of jump
- Deltas
  - At the point where we change from one self contained point
    to another, we supply the delta directly
  - Instead of calculating it from the offset calculation position.
  - And then set the offset calculation position according to the next
    actual span we see
  - We believe the start position in a span
  - It will come after a delta, so the spacing is known

** Spacing : size changes

- A typical change is to rename a variable.
- The name may be longer or shorter.
- The spacing calculation to the start point is unchanged, so all is good
- When we finish, we set the offset calculation position to the end of the span
  (We believe the end position)
- And so following spacing calculations are unaffected.

** Spacing : size changes 2

- The same principle holds for bigger changes.
- If we add additional content inside a span, it does not matter,
- The “contract” with the surroundings is the start of the span for
  entry spacing
- And the end of the span for exit spacing

** Spacing : layout

Haskell is a layout-sensitive language

#+ATTR_REVEAL: :code_attribs data-line-numbers
#+begin_src haskell
data DeltaPos
  = SameLine { deltaColumn :: Int }
  | DifferentLine { deltaLine :: Int, deltaColumn :: Int }
#+end_src

Our offset position also tracks the current indentation level, so the
~deltaColumn~ is added to that.

** Order in lists

- ~ParsedSource~ is not a completely accurate reflection of the original source.
- ~ValBinds~ separates out ~[Sig]~  and ~[Bind]~
- ~ClassDecl~ and  ~ClsInstDecl~ separate out ~Bind~ s,
  ~Sig~ s, Type family instances etc
- For all of these, the original source can have them in any order.

** Order in lists 2

- For an unmodified AST there is no problem, you just sort by start of
  span.
- But a modified one may have rearranged the existing ones, or brought
  in ones from elsewhere.
- And may have adjusted the spacing with explicit deltas.

** Order in lists 3 : Solution

- Each specific list is physically ordered, so for ~ValBinds~ we know
  the order of the sigs, and of the binds.
- But we don’t know the interleaving.
- We supply this in an ~AnnSortKey~, which drives a merge process.
- It keeps a list of ~SigDTag~ or ~BindTag~ for
  a ~ValBind~, telling which list to draw from each time.


** Order in lists, Annotation.hs comment

- From ~Note [AnnSortKey]~

We use it as a merge selector, and have one entry for each bind and
signature.

Example binds

   #+begin_src haskell
   fa :: Int
   fa = 1

   fb :: Char
   fb = 'c'
   #+end_src

This gives us ~ValBinds~ having

  #+begin_src haskell
  binds: fa = 1 , fb = 'c'
  sigs:  fa :: Int, fb :: Char
  tags: SigTag, BindTag, SigTag, BindTag
  #+end_src

so we draw first from the signatures, then the binds, and same again.


** Comments
- Comments are the ultimate “trivia”. They have no influence on
  overall spacing and layout, but need to be preserved precisely.
- They can also occur absolutely anywhere in the source file.
- So we keep them in the "~SrcSpan~ on steroids" we wrap
  everything in, and fit them in when we print, if they fit into the
  current gap.
- It’s more complicated than that, but we will look into detail later.

** Trailing Items
- The self-contained belief we base everything on is that everything fits
  inside the AST Element span.
- This is true for everything, except trailing items.
- If you consider a list of items, each item is a standalone entity
- The commas exist as part of the surrounding structure.
- So if you move the item elsewhere, or replace it with something
  else, the trailing comma should be managed as part of that location.
- Others are semicolons, vertical bars, single and double arrows

** End of Hand Wavy Part

- Hopefully you now have a high level understanding of what the exact
  print annotations are for.
- Now we can look into some details of how things are captured.


* What it means inside GHC
Time to dive into the detail. Two main divisions
- Located things
- Internal Annotations

** Trees That Grow
- GHC AST implements “Trees That Grow”
- This means extra information can be carried, computed via type classes
- Used for Exact Print Annotations (EPA)
- Uses two mechanisms
  - ~XRec~ for Located things [AZ note: not part of TTG]
  - TTG extension points for the rest

** Terminology
- AST: ~ParsedSource~

#+begin_src haskell
type ParsedSource = Located (HsModule GhcPs)
#+end_src

For now we accept ~GhcPs~ as simply a marker of the AST from the
parsing phase.

** Located Things

The AST is layered, in that alternate layer ...

*** Location

#+begin_src haskell
type family XRec p a = r | r -> a
#+end_src

#+ATTR_REVEAL: :frag t
#+begin_src haskell
type family Anno a = b
#+end_src

#+ATTR_REVEAL: :frag t
#+begin_src haskell
type instance XRec (GhcPass p) a = GenLocated (Anno a) a
#+end_src

#+ATTR_REVEAL: :frag t
#+begin_src haskell
type instance Anno (HsExpr (GhcPass p)) = SrcSpanAnnA
type LocatedA = GenLocated SrcSpanAnnA
#+end_src

#+ATTR_REVEAL: :frag t
#+begin_src haskell
type SrcSpanAnnA = EpAnn AnnListItem
#+end_src

*** EpAnn

#+begin_src haskell
data EpAnn ann = EpAnn
         { entry    :: !Anchor -- basically SrcSpan when parsed
         , anns     :: !ann
         , comments :: !EpAnnComments
         }
type Anchor = EpaLocation
#+end_src

#+ATTR_REVEAL: :frag t
#+begin_src haskell
type EpaLocation = EpaLocation' [LEpaComment]
data EpaLocation' a = EpaSpan !SrcSpan
                    | EpaDelta !DeltaPos !a
#+end_src

*** ~AnnListItem~

#+begin_src haskell
-- | Annotation for items appearing in a list. They can have one or
-- more trailing punctuations items, such as commas or semicolons.
data AnnListItem
  = AnnListItem {
      lann_trailing  :: [TrailingAnn]
      }
#+end_src

*** Sanity check

Tie up to prior hand wavy part
   #+begin_example
   (L
    (EpAnn
     (EpaSpan { DumpParsedAst.hs:5:1-16 })
     (AnnListItem
      [])
     (EpaComments
      []))
      ...
   #+end_example

- ~SrcSpan~ we "believe" is the one in the ~EpAnn~ ~entry~, using the
  ~EpaSpan~ constructor.
- If we need to move things around, the surgery happens by replacing
  it with an appropriate ~EpaDelta~ version, just for the
  point where the change happens.

#+begin_notes
- After this deep dive into types, let's come up for air a bit.
- If you recall in the handwavy part we spoke about span being the
  source of truth, the thing we believe.
- For ghc-exactprint old hands, makeDeltaAst is no longer required (but still exists)
#+end_notes

** "Trivia"

- everything that is not a location, comment, or surrounding
  information, but is needed for exact printing.
  - ~SourceText~,
  - keywords (via ~AnnKeywordId~ or ~EpToken~)

*** ~AnnKeywordId~

Original mechanism
#+begin_src haskell
data AnnKeywordId
    ...
    | AnnIn
    | AnnLet
#+end_src

*** ~EpToken~

New mechanism. May eventually supplant ~AnnKeywordId~

#+begin_src haskell
data EpToken (tok :: Symbol)
  = NoEpTok
  | EpTok !EpaLocation
#+end_src

Used as a type ~EpTok "let"~

#+ATTR_REVEAL: :frag t
Extract string for printing
#+begin_src haskell
getEpTokenString :: forall tok. KnownSymbol tok => EpToken tok -> Maybe String
getEpTokenString NoEpTok = Nothing
getEpTokenString (EpTok _) = Just $ symbolVal (Proxy @tok)
#+end_src


*** "Trivia" storage
Stored in the TTG extension points.

Refresher
#+begin_src haskell
data HsExpr p
  ...
  | HsLet (XLet p) (HsLocalBinds p) (LHsExpr  p)

type family XLet x
#+end_src

#+ATTR_REVEAL: :frag t
#+begin_src haskell
type instance XLet GhcPs = (EpToken "let", EpToken "in")
#+end_src


* What it means outside GHC
- The Exact Print Annotations are packaged for use in [[https://hackage.haskell.org/package/ghc-exactprint][ghc-exactprint]]
- Generally a "hidden" library, enabling others
  - hlint apply hints
  - various plugins in HLS
  - built for HaRe, but that now languishes
  - retrie

** ghc-exactprint big picture
- Parse
- Transform
- Print

** ghc-exactprint parsing
- ~parseModule~
- "best effort" with CPP
  - compares original with preprocessed, and turns the delta into
    comments
  - cannot work if =#define XX Blah= and then =XX= is used. =XX= added as a comment, as well as =Blah=
- Honours pragmas, but you need to set ~DynFlags~ for any e.g. project-wide options

** ghc-exactprint transform
- The reason ~ghc-exactprint~ exists
- Intention: smallest changes possible

*** Comments

Stored in ~EpAnn~

#+begin_src haskell
data EpAnnComments = EpaComments
                        { priorComments :: ![LEpaComment] }
                   | EpaCommentsBalanced
                        { priorComments     :: ![LEpaComment]
                        , followingComments :: ![LEpaComment] }
#+end_src

Once you decide to move thing around, you need to decide which
comments to bring along.

*** ~balanceComments~

~ghc-exactprint~ has ~balanceComments~ and ~balanceCommentsList~

These use heuristics to "attach" comments to the appropriate top level
declaration.

#+begin_src haskell
-- a random comment


-- here is a function
foo = 3
-- here is a trailing comment

-- Another random aside

-- another function
bar = 2
#+end_src


*** becomes

#+begin_src haskell
-- a random comment
#+end_src

#+begin_src haskell
-- here is a function
foo = 3
-- here is a trailing comment
#+end_src

#+begin_src haskell
-- Another random aside

-- another function
bar = 2
#+end_src

*** ~FunBind~ comments

- ~FunBind~ is weird
- it combines all the equations for a particular function
- each shows up as a ~Match~, which is self-contained

#+begin_src haskell
-- a random comment


-- here is a function
foo True = 3
-- here is a trailing comment

-- Another random aside

-- another function
foo False = 2
-- trailing second fun
#+end_src

*** becomes

#+begin_src haskell
-- a random comment
#+end_src

On FunBind prior comments
#+begin_src haskell
-- here is a function
#+end_src

First match (OOPS, BUG in 1.10.0.0)
#+begin_src haskell
foo True = 3
#+end_src

Second match
#+begin_src haskell
-- here is a trailing comment

-- Another random aside

-- another function
foo False = 2
#+end_src

On FunBind following comments
#+begin_src haskell
-- trailing second fun
#+end_src

*** Produced by

#+begin_src haskell
test = TestList [mkTestModChange libdir balanceComments "AFile.hs"]

balanceComments :: Changer
balanceComments _libdir lp = return $ replaceDecls lp ds'
  where
    ds = hsDecls lp
    ds' = balanceCommentsList ds
#+end_src

** ~class HasDecls~

#+begin_src haskell
class (Data t) => HasDecls t where
    hsDecls :: t -> [LHsDecl GhcPs]
    replaceDecls :: t -> [LHsDecl GhcPs] -> t
#+end_src

#+begin_notes
    - hasDecls
      - Return the 'HsDecl's that are directly enclosed in the
      given syntax phrase. They are always returned in the wrapped
      'HsDecl' form, even if orginating in local decls. This is safe,
      as annotations never attach to the wrapper, only to the wrapped
      item.
    - replaceDecls
      -
     Replace the directly enclosed decl list by the given
     decl list. As parto of replacing it will update list order
     annotations, and rebalance comments and other layout changes as needed.
    --
    For example, a call on replaceDecls for a wrapped 'FunBind' having no
    where clause will convert
    --
    @
    -- |This is a function
    foo = x -- comment1
    --
    in to
    --
    -- |This is a function
    foo = x -- comment1
      where
        nn = 2
#+end_notes

*** ~replaceDecls~

    #+begin_src haskell
    -- |This is a function
    foo = x -- comment1
    -- trailing comment
    #+end_src

    to

    #+begin_src haskell
    -- |This is a function
    foo = x -- comment1
      where
        nn = 2
    -- trailing comment
    #+end_src

*** code for the replace

#+begin_src haskell
addLocaLDecl1 :: Changer
addLocaLDecl1 libdir top = do
  Right (L ld (ValD _ decl)) <- withDynFlags libdir (\df -> parseDecl df "decl" "nn = 2")
  let
      decl' = setEntryDP (L ld decl) (DifferentLine 1 5)
      (de1:d2:d3:_) = hsDecls top
      (de1',d2') = balanceComments de1 d2
      (de1'',_) = modifyValD (getLocA de1') de1' $ \_m d ->
                   ((wrapDecl decl' : d), Nothing)
  return $ replaceDecls top [de1'', d2', d3]
#+end_src

*** ~modifyValD~
- Remember ~FunBind~?

#+begin_src haskell
..
[ma1,_ma2] = ms -- of de1
(de1',_) = modifyValD (getLocA ma1) de1 $ \_m decls ->
             (newDecl : decls, Nothing)
#+end_src

#+begin_src haskell
type Decl  = LHsDecl GhcPs
type PMatch = LMatch GhcPs (LHsExpr GhcPs)
modifyValD
   :: forall t. SrcSpan -> Decl
   -> (PMatch -> [Decl] -> ([Decl], Maybe t))
   -> (Decl, Maybe t)
#+end_src


#+begin_notes
-- |Modify a 'LHsBind' wrapped in a 'ValD'. For a 'PatBind' the
-- declarations are extracted and returned after modification. For a
-- 'FunBind' the supplied 'SrcSpan' is used to identify the specific
-- 'Match' to be transformed, for when there are multiple of them.

Note: now that everything is pure, and connected, pretty much not
needed.
#+end_notes

*** packFunBind, unpackFunBind
And packFunDecl, unpackFunDecl

*** addToList etc

*** replaceDecls sort order
- Remember ~AnnSortKey~?
- It is populated in ~replaceDecls~
- ~captureOrderBinds~
- ~replaceDeclsClassDecl~ (and ~hsDeclsClassDecl~)

- ~oderedDecls~
  When ~NoAnnSortKey~,
  - Assume working with an unchanged AST
  - use the locations of the decls and sort
  When ~AnnSortKey DeclTag~
  - Build ~Map.Map DeclTag [LHsDecl GhcPs]~ from assorted ~ClassDecl~ parts
  - 

** Summary
- balance comments
- manage funbind comment details
- manage ~where~ for adding/removing decls to ~HsValBinds~
- track sort order
- wrap/unwrap binds

** ghc-exactprint print
This is the heart of the thing

But will not look in detail, it is too complex

Suffice to say,

#+begin_src haskell
exactPrint :: ExactPrint ast => ast -> String
#+end_src

** Name tie-ups
- All ~RdrName~ s in the AST are ~LocatedN~, containing
  a ~SrcSpan~ when originally parsed.
- The ~RenamedSource~ does not remove named locations,
  although it may move them around a bit.
- So perform a generic traversal of the ~RenamedSource~,
  building a map of
 #+begin_src haskell
 SrcSpan -> Name
 #+end_src


* Future
- Fixity info
- ~GHC_CPP~
- Free vars?
- Easy Export of Name table for lookup?
- ghc-exactprint API
  - currently provisional
  - should it be split?
  - where should it live?
- Link-up with ghc-lib-parser

* End
